###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        20/Mar/2015  10:30:56
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  E:\LPLD_OSKinetis_V3_now02\project\LPLD_OV7670\app\uart.c
#    Command line =  
#        E:\LPLD_OSKinetis_V3_now02\project\LPLD_OV7670\app\uart.c -D LPLD_K60
#        -lCN E:\LPLD_OSKinetis_V3_now02\project\LPLD_OV7670\iar\RAM\List\ -lB
#        E:\LPLD_OSKinetis_V3_now02\project\LPLD_OV7670\iar\RAM\List\ -o
#        E:\LPLD_OSKinetis_V3_now02\project\LPLD_OV7670\iar\RAM\Obj\ --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        E:\LPLD_OSKinetis_V3_now02\project\LPLD_OV7670\iar\..\app\ -I
#        E:\LPLD_OSKinetis_V3_now02\project\LPLD_OV7670\iar\..\..\..\lib\CPU\
#        -I
#        E:\LPLD_OSKinetis_V3_now02\project\LPLD_OV7670\iar\..\..\..\lib\common\
#        -I
#        E:\LPLD_OSKinetis_V3_now02\project\LPLD_OV7670\iar\..\..\..\lib\LPLD\
#        -I
#        E:\LPLD_OSKinetis_V3_now02\project\LPLD_OV7670\iar\..\..\..\lib\LPLD\HW\
#        -I
#        E:\LPLD_OSKinetis_V3_now02\project\LPLD_OV7670\iar\..\..\..\lib\LPLD\DEV\
#        -I
#        E:\LPLD_OSKinetis_V3_now02\project\LPLD_OV7670\iar\..\..\..\lib\uCOS-II\Ports\
#        -I
#        E:\LPLD_OSKinetis_V3_now02\project\LPLD_OV7670\iar\..\..\..\lib\uCOS-II\Source\
#        -I
#        E:\LPLD_OSKinetis_V3_now02\project\LPLD_OV7670\iar\..\..\..\lib\FatFs\
#        -I
#        E:\LPLD_OSKinetis_V3_now02\project\LPLD_OV7670\iar\..\..\..\lib\FatFs\option\
#        -I
#        E:\LPLD_OSKinetis_V3_now02\project\LPLD_OV7670\iar\..\..\..\lib\USB\common\
#        -I
#        E:\LPLD_OSKinetis_V3_now02\project\LPLD_OV7670\iar\..\..\..\lib\USB\driver\
#        -I
#        E:\LPLD_OSKinetis_V3_now02\project\LPLD_OV7670\iar\..\..\..\lib\USB\descriptor\
#        -I
#        E:\LPLD_OSKinetis_V3_now02\project\LPLD_OV7670\iar\..\..\..\lib\USB\class\
#        -Ol -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\CMSIS\Include\" -D ARM_MATH_CM4
#    List file    =  
#        E:\LPLD_OSKinetis_V3_now02\project\LPLD_OV7670\iar\RAM\List\uart.lst
#    Object file  =  
#        E:\LPLD_OSKinetis_V3_now02\project\LPLD_OV7670\iar\RAM\Obj\uart.o
#
###############################################################################

E:\LPLD_OSKinetis_V3_now02\project\LPLD_OV7670\app\uart.c
      1          #include "common.h"
      2          #include "uart.h"
      3          #include <stdarg.h>
      4          
      5          
      6          void cpshuzu (int8 *s, const int8 *fmt, uint8 start,uint8 stop);
      7          

   \                                 In section .bss, align 4
      8          UART_InitTypeDef uart0_init_struct;
   \                     uart0_init_struct:
   \   00000000                      DS8 20

   \                                 In section .bss, align 4
      9          UART_InitTypeDef uart1_init_struct;
   \                     uart1_init_struct:
   \   00000000                      DS8 20

   \                                 In section .bss, align 4
     10          UART_InitTypeDef uart2_init_struct;
   \                     uart2_init_struct:
   \   00000000                      DS8 20

   \                                 In section .bss, align 4
     11          UART_InitTypeDef uart3_init_struct;
   \                     uart3_init_struct:
   \   00000000                      DS8 20

   \                                 In section .bss, align 4
     12          UART_InitTypeDef uart4_init_struct;
   \                     uart4_init_struct:
   \   00000000                      DS8 20

   \                                 In section .bss, align 4
     13          UART_InitTypeDef uart5_init_struct;
   \                     uart5_init_struct:
   \   00000000                      DS8 20
     14          
     15          void uart0_isr(void);
     16          void uart1_isr(void);
     17          void uart2_isr(void);
     18          void uart3_isr(void);
     19          void uart4_isr(void);
     20          void uart5_isr(void);
     21          
     22          

   \                                 In section .data, align 1
     23          uint8 gps_flag=1,step=0,t1=0,t2=0,t3=0,t4=0;
   \                     gps_flag:
   \   00000000   0x01               DC8 1

   \                                 In section .bss, align 1
   \                     step:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \                     t1:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \                     t2:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \                     t3:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \                     t4:
   \   00000000                      DS8 1
     24          

   \                                 In section .bss, align 4
     25          uint8 GPS_HEAD[5],E,test[80],gps_test[80],gps_gga[80];
   \                     GPS_HEAD:
   \   00000000                      DS8 8

   \                                 In section .bss, align 1
   \                     E:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
   \                     test:
   \   00000000                      DS8 80

   \                                 In section .bss, align 4
   \                     gps_test:
   \   00000000                      DS8 80

   \                                 In section .bss, align 4
   \                     gps_gga:
   \   00000000                      DS8 80
     26          

   \                                 In section .bss, align 1
     27          uint8 uart_step=0,step_buf=0,test1=0;
   \                     uart_step:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \                     step_buf:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \                     test1:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
     28          int8 buf[20];
   \                     buf:
   \   00000000                      DS8 20

   \                                 In section .bss, align 4
     29          uint8 uart0_rev[100],uart1_rev[100],uart2_rev[100],uart3_rev[100],\
   \                     uart0_rev:
   \   00000000                      DS8 100

   \                                 In section .bss, align 4
   \                     uart1_rev:
   \   00000000                      DS8 100

   \                                 In section .bss, align 4
   \                     uart2_rev:
   \   00000000                      DS8 100

   \                                 In section .bss, align 4
   \                     uart3_rev:
   \   00000000                      DS8 100

   \                                 In section .bss, align 4
     30          uart4_rev[100],uart5_rev[100];
   \                     uart4_rev:
   \   00000000                      DS8 100

   \                                 In section .bss, align 4
   \                     uart5_rev:
   \   00000000                      DS8 100

   \                                 In section .bss, align 1
     31          uint8 uart0__flag_rev,uart1_flag_rev,uart2_flag_rev,uart3_flag_rev,\
   \                     uart0__flag_rev:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \                     uart1_flag_rev:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \                     uart2_flag_rev:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \                     uart3_flag_rev:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     32          uart4_flag_rev,uart5_flag_rev;
   \                     uart4_flag_rev:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \                     uart5_flag_rev:
   \   00000000                      DS8 1
     33              
     34          //enum {
     35          //UART0；
     36          //UART1；
     37          //UART2；
     38          //UART3；
     39          //UART4；
     40          //UART5；
     41          //}
     42          

   \                                 In section .text, align 2, keep-with-next
     43          void uart_init(void)
     44          {
   \                     uart_init: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     45          
     46            
     47            /*
     48            UART0   TXD0:PTB17   RXD0:PTB16      USB->UART 
     49            UART1   TXD1:PTE0    RXD1:PTE1       WIFI
     50            //UART2   TXD2:PTE0    RXD2:PTE1    
     51            UART3   TXD3:PTE4    RXD3:PTE5       北斗/GPS
     52            UART4   TXD4:PTE24   RXD4:PTE25      Zigbee
     53            UART5   TXD5:PTE8    RXD5:PTE9       GPRS
     54            */
     55            /*   init uart0   USB->UART  115200*/
     56            uart0_init_struct.UART_Uartx = UART0; //使用UART0
   \   00000002   0x....             LDR.N    R0,??DataTable6  ;; 0x4006a000
   \   00000004   0x....             LDR.N    R1,??DataTable6_1
   \   00000006   0x6008             STR      R0,[R1, #+0]
     57            uart0_init_struct.UART_BaudRate = 115200; //设置波特率9600
   \   00000008   0xF45F 0x30E1      MOVS     R0,#+115200
   \   0000000C   0x....             LDR.N    R1,??DataTable6_1
   \   0000000E   0x6048             STR      R0,[R1, #+4]
     58            uart0_init_struct.UART_RxPin = PTB16;  //接收引脚为PTE9
   \   00000010   0x2030             MOVS     R0,#+48
   \   00000012   0x....             LDR.N    R1,??DataTable6_1
   \   00000014   0x7248             STRB     R0,[R1, #+9]
     59            uart0_init_struct.UART_TxPin = PTB17;  //发送引脚为PTE8
   \   00000016   0x2031             MOVS     R0,#+49
   \   00000018   0x....             LDR.N    R1,??DataTable6_1
   \   0000001A   0x7208             STRB     R0,[R1, #+8]
     60            uart0_init_struct.UART_RxIntEnable = TRUE;    //使能接收中断
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0x....             LDR.N    R1,??DataTable6_1
   \   00000020   0x7288             STRB     R0,[R1, #+10]
     61            uart0_init_struct.UART_RxIsr = uart0_isr;      //设置接收中断函数
   \   00000022   0x.... 0x....      ADR.W    R0,uart0_isr
   \   00000026   0x....             LDR.N    R1,??DataTable6_1
   \   00000028   0x60C8             STR      R0,[R1, #+12]
     62            LPLD_UART_Init(uart0_init_struct);//初始化UART 
   \   0000002A   0x....             LDR.N    R1,??DataTable6_1
   \   0000002C   0xB084             SUB      SP,SP,#+16
   \   0000002E   0x4668             MOV      R0,SP
   \   00000030   0x2214             MOVS     R2,#+20
   \   00000032   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000036   0xBC0F             POP      {R0-R3}
   \   00000038   0x.... 0x....      BL       LPLD_UART_Init
     63            LPLD_UART_EnableIrq(uart0_init_struct);//使能UART中断
   \   0000003C   0x....             LDR.N    R1,??DataTable6_1
   \   0000003E   0xB084             SUB      SP,SP,#+16
   \   00000040   0x4668             MOV      R0,SP
   \   00000042   0x2214             MOVS     R2,#+20
   \   00000044   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000048   0xBC0F             POP      {R0-R3}
   \   0000004A   0x.... 0x....      BL       LPLD_UART_EnableIrq
     64            /*   init uart1  WIFI  115200     */
     65            uart1_init_struct.UART_Uartx = UART1; //使用UART1
   \   0000004E   0x....             LDR.N    R0,??DataTable6_2  ;; 0x4006b000
   \   00000050   0x....             LDR.N    R1,??DataTable6_3
   \   00000052   0x6008             STR      R0,[R1, #+0]
     66            uart1_init_struct.UART_BaudRate = 115200; //设置波特率9600
   \   00000054   0xF45F 0x30E1      MOVS     R0,#+115200
   \   00000058   0x....             LDR.N    R1,??DataTable6_3
   \   0000005A   0x6048             STR      R0,[R1, #+4]
     67            uart1_init_struct.UART_RxPin = PTE2;  //接收引脚为PTE9
   \   0000005C   0x207E             MOVS     R0,#+126
   \   0000005E   0x....             LDR.N    R1,??DataTable6_3
   \   00000060   0x7248             STRB     R0,[R1, #+9]
     68            uart1_init_struct.UART_TxPin = PTE0;  //发送引脚为PTE8
   \   00000062   0x207C             MOVS     R0,#+124
   \   00000064   0x....             LDR.N    R1,??DataTable6_3
   \   00000066   0x7208             STRB     R0,[R1, #+8]
     69            uart1_init_struct.UART_RxIntEnable = TRUE;    //使能接收中断
   \   00000068   0x2001             MOVS     R0,#+1
   \   0000006A   0x....             LDR.N    R1,??DataTable6_3
   \   0000006C   0x7288             STRB     R0,[R1, #+10]
     70            uart1_init_struct.UART_RxIsr = uart1_isr;      //设置接收中断函数
   \   0000006E   0x.... 0x....      ADR.W    R0,uart1_isr
   \   00000072   0x....             LDR.N    R1,??DataTable6_3
   \   00000074   0x60C8             STR      R0,[R1, #+12]
     71            LPLD_UART_Init(uart1_init_struct);//初始化UART 
   \   00000076   0x....             LDR.N    R1,??DataTable6_3
   \   00000078   0xB084             SUB      SP,SP,#+16
   \   0000007A   0x4668             MOV      R0,SP
   \   0000007C   0x2214             MOVS     R2,#+20
   \   0000007E   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000082   0xBC0F             POP      {R0-R3}
   \   00000084   0x.... 0x....      BL       LPLD_UART_Init
     72            LPLD_UART_EnableIrq(uart1_init_struct);//使能UART中断 
   \   00000088   0x....             LDR.N    R1,??DataTable6_3
   \   0000008A   0xB084             SUB      SP,SP,#+16
   \   0000008C   0x4668             MOV      R0,SP
   \   0000008E   0x2214             MOVS     R2,#+20
   \   00000090   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000094   0xBC0F             POP      {R0-R3}
   \   00000096   0x.... 0x....      BL       LPLD_UART_EnableIrq
     73            ////  /*   init uart2  */
     74            ////  uart2_init_struct.UART_Uartx = UART2; //使用UART2
     75            ////  uart2_init_struct.UART_BaudRate = 115200; //设置波特率9600
     76            ////  uart2_init_struct.UART_RxPin = PTE1;  //接收引脚为PTE9
     77            ////  uart2_init_struct.UART_TxPin = PTE0;  //发送引脚为PTE8
     78            ////  uart2_init_struct.UART_RxIntEnable = TRUE;    //使能接收中断
     79            ////  uart2_init_struct.UART_RxIsr = uart2_isr;      //设置接收中断函数
     80            ////  LPLD_UART_Init(uart2_init_struct);//初始化UART 
     81            ////  LPLD_UART_EnableIrq(uart2_init_struct);//使能UART中断
     82            /*   init uart3  北斗/GPS  115200  */
     83            uart3_init_struct.UART_Uartx = UART3; //使用UART3
   \   0000009A   0x....             LDR.N    R0,??DataTable6_4  ;; 0x4006d000
   \   0000009C   0x....             LDR.N    R1,??DataTable6_5
   \   0000009E   0x6008             STR      R0,[R1, #+0]
     84            uart3_init_struct.UART_BaudRate = 9600; //设置波特率9600
   \   000000A0   0xF44F 0x5016      MOV      R0,#+9600
   \   000000A4   0x....             LDR.N    R1,??DataTable6_5
   \   000000A6   0x6048             STR      R0,[R1, #+4]
     85            uart3_init_struct.UART_RxPin = PTE5;  //接收引脚为PTE9
   \   000000A8   0x2081             MOVS     R0,#+129
   \   000000AA   0x....             LDR.N    R1,??DataTable6_5
   \   000000AC   0x7248             STRB     R0,[R1, #+9]
     86            uart3_init_struct.UART_TxPin = PTE4;  //发送引脚为PTE8
   \   000000AE   0x2080             MOVS     R0,#+128
   \   000000B0   0x....             LDR.N    R1,??DataTable6_5
   \   000000B2   0x7208             STRB     R0,[R1, #+8]
     87            uart3_init_struct.UART_RxIntEnable = TRUE;    //使能接收中断
   \   000000B4   0x2001             MOVS     R0,#+1
   \   000000B6   0x....             LDR.N    R1,??DataTable6_5
   \   000000B8   0x7288             STRB     R0,[R1, #+10]
     88            uart3_init_struct.UART_RxIsr = uart3_isr;      //设置接收中断函数
   \   000000BA   0x.... 0x....      ADR.W    R0,uart3_isr
   \   000000BE   0x....             LDR.N    R1,??DataTable6_5
   \   000000C0   0x60C8             STR      R0,[R1, #+12]
     89            LPLD_UART_Init(uart3_init_struct);//初始化UART 
   \   000000C2   0x....             LDR.N    R1,??DataTable6_5
   \   000000C4   0xB084             SUB      SP,SP,#+16
   \   000000C6   0x4668             MOV      R0,SP
   \   000000C8   0x2214             MOVS     R2,#+20
   \   000000CA   0x.... 0x....      BL       __aeabi_memcpy4
   \   000000CE   0xBC0F             POP      {R0-R3}
   \   000000D0   0x.... 0x....      BL       LPLD_UART_Init
     90            LPLD_UART_EnableIrq(uart3_init_struct);//使能UART中断
   \   000000D4   0x....             LDR.N    R1,??DataTable6_5
   \   000000D6   0xB084             SUB      SP,SP,#+16
   \   000000D8   0x4668             MOV      R0,SP
   \   000000DA   0x2214             MOVS     R2,#+20
   \   000000DC   0x.... 0x....      BL       __aeabi_memcpy4
   \   000000E0   0xBC0F             POP      {R0-R3}
   \   000000E2   0x.... 0x....      BL       LPLD_UART_EnableIrq
     91            /*   init uart4    Zigbee */
     92            uart4_init_struct.UART_Uartx = UART4; //使用UART4
   \   000000E6   0x....             LDR.N    R0,??DataTable6_6  ;; 0x400ea000
   \   000000E8   0x....             LDR.N    R1,??DataTable6_7
   \   000000EA   0x6008             STR      R0,[R1, #+0]
     93            uart4_init_struct.UART_BaudRate = 115200; //设置波特率9600
   \   000000EC   0xF45F 0x30E1      MOVS     R0,#+115200
   \   000000F0   0x....             LDR.N    R1,??DataTable6_7
   \   000000F2   0x6048             STR      R0,[R1, #+4]
     94            uart4_init_struct.UART_RxPin = PTE25;  //接收引脚为PTE9
   \   000000F4   0x2095             MOVS     R0,#+149
   \   000000F6   0x....             LDR.N    R1,??DataTable6_7
   \   000000F8   0x7248             STRB     R0,[R1, #+9]
     95            uart4_init_struct.UART_TxPin = PTE24;  //发送引脚为PTE8
   \   000000FA   0x2094             MOVS     R0,#+148
   \   000000FC   0x....             LDR.N    R1,??DataTable6_7
   \   000000FE   0x7208             STRB     R0,[R1, #+8]
     96            uart4_init_struct.UART_RxIntEnable = TRUE;    //使能接收中断
   \   00000100   0x2001             MOVS     R0,#+1
   \   00000102   0x....             LDR.N    R1,??DataTable6_7
   \   00000104   0x7288             STRB     R0,[R1, #+10]
     97            uart4_init_struct.UART_RxIsr = uart4_isr;      //设置接收中断函数
   \   00000106   0x.... 0x....      ADR.W    R0,uart4_isr
   \   0000010A   0x....             LDR.N    R1,??DataTable6_7
   \   0000010C   0x60C8             STR      R0,[R1, #+12]
     98            LPLD_UART_Init(uart4_init_struct);//初始化UART 
   \   0000010E   0x....             LDR.N    R1,??DataTable6_7
   \   00000110   0xB084             SUB      SP,SP,#+16
   \   00000112   0x4668             MOV      R0,SP
   \   00000114   0x2214             MOVS     R2,#+20
   \   00000116   0x.... 0x....      BL       __aeabi_memcpy4
   \   0000011A   0xBC0F             POP      {R0-R3}
   \   0000011C   0x.... 0x....      BL       LPLD_UART_Init
     99            LPLD_UART_EnableIrq(uart4_init_struct);//使能UART中断
   \   00000120   0x....             LDR.N    R1,??DataTable6_7
   \   00000122   0xB084             SUB      SP,SP,#+16
   \   00000124   0x4668             MOV      R0,SP
   \   00000126   0x2214             MOVS     R2,#+20
   \   00000128   0x.... 0x....      BL       __aeabi_memcpy4
   \   0000012C   0xBC0F             POP      {R0-R3}
   \   0000012E   0x.... 0x....      BL       LPLD_UART_EnableIrq
    100            /*   init uart5   GPRS  115200 */
    101            uart5_init_struct.UART_Uartx = UART5; //使用UART5
   \   00000132   0x....             LDR.N    R0,??DataTable6_8  ;; 0x400eb000
   \   00000134   0x....             LDR.N    R1,??DataTable6_9
   \   00000136   0x6008             STR      R0,[R1, #+0]
    102            uart5_init_struct.UART_BaudRate = 115200; //设置波特率9600
   \   00000138   0xF45F 0x30E1      MOVS     R0,#+115200
   \   0000013C   0x....             LDR.N    R1,??DataTable6_9
   \   0000013E   0x6048             STR      R0,[R1, #+4]
    103            uart5_init_struct.UART_RxPin = PTE9;  //接收引脚为PTE9
   \   00000140   0x2085             MOVS     R0,#+133
   \   00000142   0x....             LDR.N    R1,??DataTable6_9
   \   00000144   0x7248             STRB     R0,[R1, #+9]
    104            uart5_init_struct.UART_TxPin = PTE8;  //发送引脚为PTE8
   \   00000146   0x2084             MOVS     R0,#+132
   \   00000148   0x....             LDR.N    R1,??DataTable6_9
   \   0000014A   0x7208             STRB     R0,[R1, #+8]
    105            uart5_init_struct.UART_RxIntEnable = TRUE;    //使能接收中断
   \   0000014C   0x2001             MOVS     R0,#+1
   \   0000014E   0x....             LDR.N    R1,??DataTable6_9
   \   00000150   0x7288             STRB     R0,[R1, #+10]
    106            uart5_init_struct.UART_RxIsr = uart5_isr;      //设置接收中断函数
   \   00000152   0x.... 0x....      ADR.W    R0,uart5_isr
   \   00000156   0x....             LDR.N    R1,??DataTable6_9
   \   00000158   0x60C8             STR      R0,[R1, #+12]
    107            LPLD_UART_Init(uart5_init_struct);//初始化UART 
   \   0000015A   0x....             LDR.N    R1,??DataTable6_9
   \   0000015C   0xB084             SUB      SP,SP,#+16
   \   0000015E   0x4668             MOV      R0,SP
   \   00000160   0x2214             MOVS     R2,#+20
   \   00000162   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000166   0xBC0F             POP      {R0-R3}
   \   00000168   0x.... 0x....      BL       LPLD_UART_Init
    108            LPLD_UART_EnableIrq(uart5_init_struct);//使能UART中断
   \   0000016C   0x....             LDR.N    R1,??DataTable6_9
   \   0000016E   0xB084             SUB      SP,SP,#+16
   \   00000170   0x4668             MOV      R0,SP
   \   00000172   0x2214             MOVS     R2,#+20
   \   00000174   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000178   0xBC0F             POP      {R0-R3}
   \   0000017A   0x.... 0x....      BL       LPLD_UART_EnableIrq
    109            
    110            
    111          }
   \   0000017E   0xBD01             POP      {R0,PC}          ;; return
    112          
    113          
    114          
    115          /*    uart0  USB->UART中断服务函数    */

   \                                 In section .text, align 4, keep-with-next
    116          void uart0_isr(void)
    117          {
   \                     uart0_isr: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    118            int8 recv;
    119            recv = LPLD_UART_GetChar(UART0);
   \   00000002   0x....             LDR.N    R0,??DataTable6  ;; 0x4006a000
   \   00000004   0x.... 0x....      BL       LPLD_UART_GetChar
    120            
    121            LPLD_UART_PutChar(UART5, recv);
   \   00000008   0x0001             MOVS     R1,R0
   \   0000000A   0xB249             SXTB     R1,R1            ;; SignExt  R1,R1,#+24,#+24
   \   0000000C   0x....             LDR.N    R0,??DataTable6_8  ;; 0x400eb000
   \   0000000E   0x.... 0x....      BL       LPLD_UART_PutChar
    122          }
   \   00000012   0xBD01             POP      {R0,PC}          ;; return
    123          
    124          /*    uart1 WIFI中断服务函数    */

   \                                 In section .text, align 4, keep-with-next
    125          void uart1_isr(void)
    126          {
   \                     uart1_isr: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    127            int8 recv;
    128            recv = LPLD_UART_GetChar(UART1);
   \   00000002   0x....             LDR.N    R0,??DataTable6_2  ;; 0x4006b000
   \   00000004   0x.... 0x....      BL       LPLD_UART_GetChar
    129            LPLD_UART_PutChar(UART0, recv);
   \   00000008   0x0001             MOVS     R1,R0
   \   0000000A   0xB249             SXTB     R1,R1            ;; SignExt  R1,R1,#+24,#+24
   \   0000000C   0x....             LDR.N    R0,??DataTable6  ;; 0x4006a000
   \   0000000E   0x.... 0x....      BL       LPLD_UART_PutChar
    130            
    131          }
   \   00000012   0xBD01             POP      {R0,PC}          ;; return
    132          
    133          /*    uart2 中断服务函数    */

   \                                 In section .text, align 2, keep-with-next
    134          void uart2_isr(void)
    135          {
   \                     uart2_isr: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    136            int8 recv;
    137            recv = LPLD_UART_GetChar(UART2);
   \   00000002   0x....             LDR.N    R0,??DataTable6_10  ;; 0x4006c000
   \   00000004   0x.... 0x....      BL       LPLD_UART_GetChar
    138            LPLD_UART_PutChar(UART0, recv);
   \   00000008   0x0001             MOVS     R1,R0
   \   0000000A   0xB249             SXTB     R1,R1            ;; SignExt  R1,R1,#+24,#+24
   \   0000000C   0x....             LDR.N    R0,??DataTable6  ;; 0x4006a000
   \   0000000E   0x.... 0x....      BL       LPLD_UART_PutChar
    139          }
   \   00000012   0xBD01             POP      {R0,PC}          ;; return
    140          
    141          /*    uart3  北斗/GPS中断服务函数    */

   \                                 In section .text, align 4, keep-with-next
    142          void uart3_isr(void)
    143          {
   \                     uart3_isr: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    144            int8 recv;
    145            recv = LPLD_UART_GetChar(UART3);
   \   00000002   0x....             LDR.N    R0,??DataTable6_4  ;; 0x4006d000
   \   00000004   0x.... 0x....      BL       LPLD_UART_GetChar
   \   00000008   0x0004             MOVS     R4,R0
    146            
    147            if(1==step)
   \   0000000A   0x....             LDR.N    R0,??DataTable6_11
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x2801             CMP      R0,#+1
   \   00000010   0xD10F             BNE.N    ??uart3_isr_0
    148            {
    149              /*接收数据头*/
    150              GPS_HEAD[t1] = recv;  
   \   00000012   0x....             LDR.N    R0,??DataTable6_12
   \   00000014   0x7800             LDRB     R0,[R0, #+0]
   \   00000016   0x....             LDR.N    R1,??DataTable6_13
   \   00000018   0x5444             STRB     R4,[R0, R1]
    151              t1++;
   \   0000001A   0x....             LDR.N    R0,??DataTable6_12
   \   0000001C   0x7800             LDRB     R0,[R0, #+0]
   \   0000001E   0x1C40             ADDS     R0,R0,#+1
   \   00000020   0x....             LDR.N    R1,??DataTable6_12
   \   00000022   0x7008             STRB     R0,[R1, #+0]
    152              if(t1==5)
   \   00000024   0x....             LDR.N    R0,??DataTable6_12
   \   00000026   0x7800             LDRB     R0,[R0, #+0]
   \   00000028   0x2805             CMP      R0,#+5
   \   0000002A   0xD102             BNE.N    ??uart3_isr_0
    153                step=2;    
   \   0000002C   0x2002             MOVS     R0,#+2
   \   0000002E   0x....             LDR.N    R1,??DataTable6_11
   \   00000030   0x7008             STRB     R0,[R1, #+0]
    154            } 
    155            
    156            if(step == 3)
   \                     ??uart3_isr_0: (+1)
   \   00000032   0x....             LDR.N    R0,??DataTable6_11
   \   00000034   0x7800             LDRB     R0,[R0, #+0]
   \   00000036   0x2803             CMP      R0,#+3
   \   00000038   0xD112             BNE.N    ??uart3_isr_1
    157            {
    158              if('$' == recv) 
   \   0000003A   0xB264             SXTB     R4,R4            ;; SignExt  R4,R4,#+24,#+24
   \   0000003C   0x2C24             CMP      R4,#+36
   \   0000003E   0xD106             BNE.N    ??uart3_isr_2
    159              {
    160                step=0;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x....             LDR.N    R1,??DataTable6_11
   \   00000044   0x7008             STRB     R0,[R1, #+0]
    161                gps_flag=0;
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x....             LDR.N    R1,??DataTable6_14
   \   0000004A   0x7008             STRB     R0,[R1, #+0]
   \   0000004C   0xE008             B.N      ??uart3_isr_1
    162              }
    163              else 
    164              {
    165                gps_gga[t3]=recv;
   \                     ??uart3_isr_2: (+1)
   \   0000004E   0x....             LDR.N    R0,??DataTable6_15
   \   00000050   0x7800             LDRB     R0,[R0, #+0]
   \   00000052   0x....             LDR.N    R1,??DataTable6_16
   \   00000054   0x5444             STRB     R4,[R0, R1]
    166                t3++;
   \   00000056   0x....             LDR.N    R0,??DataTable6_15
   \   00000058   0x7800             LDRB     R0,[R0, #+0]
   \   0000005A   0x1C40             ADDS     R0,R0,#+1
   \   0000005C   0x....             LDR.N    R1,??DataTable6_15
   \   0000005E   0x7008             STRB     R0,[R1, #+0]
    167              } 
    168              
    169            }
    170            if(step == 2  && !strcmp(GPS_HEAD,"GNGGA"))
   \                     ??uart3_isr_1: (+1)
   \   00000060   0x....             LDR.N    R0,??DataTable6_11
   \   00000062   0x7800             LDRB     R0,[R0, #+0]
   \   00000064   0x2802             CMP      R0,#+2
   \   00000066   0xD10B             BNE.N    ??uart3_isr_3
   \   00000068   0x....             LDR.N    R1,??DataTable6_17
   \   0000006A   0x....             LDR.N    R0,??DataTable6_13
   \   0000006C   0x.... 0x....      BL       strcmp
   \   00000070   0x2800             CMP      R0,#+0
   \   00000072   0xD105             BNE.N    ??uart3_isr_3
    171            {
    172              step = 3;
   \   00000074   0x2003             MOVS     R0,#+3
   \   00000076   0x....             LDR.N    R1,??DataTable6_11
   \   00000078   0x7008             STRB     R0,[R1, #+0]
    173              t3=0;
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0x....             LDR.N    R1,??DataTable6_15
   \   0000007E   0x7008             STRB     R0,[R1, #+0]
    174            }
    175            
    176            if('$' == recv && gps_flag)
   \                     ??uart3_isr_3: (+1)
   \   00000080   0xB264             SXTB     R4,R4            ;; SignExt  R4,R4,#+24,#+24
   \   00000082   0x2C24             CMP      R4,#+36
   \   00000084   0xD10C             BNE.N    ??uart3_isr_4
   \   00000086   0x....             LDR.N    R0,??DataTable6_14
   \   00000088   0x7800             LDRB     R0,[R0, #+0]
   \   0000008A   0x2800             CMP      R0,#+0
   \   0000008C   0xD008             BEQ.N    ??uart3_isr_4
    177            {
    178              step=1;
   \   0000008E   0x2001             MOVS     R0,#+1
   \   00000090   0x....             LDR.N    R1,??DataTable6_11
   \   00000092   0x7008             STRB     R0,[R1, #+0]
    179              t2=0;
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0x....             LDR.N    R1,??DataTable6_18
   \   00000098   0x7008             STRB     R0,[R1, #+0]
    180              t1=0;
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0x....             LDR.N    R1,??DataTable6_12
   \   0000009E   0x7008             STRB     R0,[R1, #+0]
    181            }  
    182            test[t2] = recv;
   \                     ??uart3_isr_4: (+1)
   \   000000A0   0x....             LDR.N    R0,??DataTable6_18
   \   000000A2   0x7800             LDRB     R0,[R0, #+0]
   \   000000A4   0x....             LDR.N    R1,??DataTable6_19
   \   000000A6   0x5444             STRB     R4,[R0, R1]
    183            t2++;    
   \   000000A8   0x....             LDR.N    R0,??DataTable6_18
   \   000000AA   0x7800             LDRB     R0,[R0, #+0]
   \   000000AC   0x1C40             ADDS     R0,R0,#+1
   \   000000AE   0x....             LDR.N    R1,??DataTable6_18
   \   000000B0   0x7008             STRB     R0,[R1, #+0]
    184           // LPLD_UART_PutChar(UART0, recv);
    185            
    186          }
   \   000000B2   0xBD10             POP      {R4,PC}          ;; return
    187          
    188          /*    uart4 Zigbee中断服务函数    */

   \                                 In section .text, align 4, keep-with-next
    189          void uart4_isr(void)
    190          {
   \                     uart4_isr: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    191            int8 recv;
    192            uart_step=1;
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x....             LDR.N    R1,??DataTable6_20
   \   00000006   0x7008             STRB     R0,[R1, #+0]
    193            recv = LPLD_UART_GetChar(UART4);
   \   00000008   0x....             LDR.N    R0,??DataTable6_6  ;; 0x400ea000
   \   0000000A   0x.... 0x....      BL       LPLD_UART_GetChar
   \   0000000E   0x0004             MOVS     R4,R0
    194            LPLD_UART_PutChar(UART0, recv);
   \   00000010   0x0021             MOVS     R1,R4
   \   00000012   0xB249             SXTB     R1,R1            ;; SignExt  R1,R1,#+24,#+24
   \   00000014   0x....             LDR.N    R0,??DataTable6  ;; 0x4006a000
   \   00000016   0x.... 0x....      BL       LPLD_UART_PutChar
    195            buf[step_buf] = recv;
   \   0000001A   0x....             LDR.N    R0,??DataTable6_21
   \   0000001C   0x7800             LDRB     R0,[R0, #+0]
   \   0000001E   0x....             LDR.N    R1,??DataTable6_22
   \   00000020   0x5444             STRB     R4,[R0, R1]
    196            step_buf++;  
   \   00000022   0x....             LDR.N    R0,??DataTable6_21
   \   00000024   0x7800             LDRB     R0,[R0, #+0]
   \   00000026   0x1C40             ADDS     R0,R0,#+1
   \   00000028   0x....             LDR.N    R1,??DataTable6_21
   \   0000002A   0x7008             STRB     R0,[R1, #+0]
    197            test1 = 0;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x....             LDR.N    R1,??DataTable6_23
   \   00000030   0x7008             STRB     R0,[R1, #+0]
    198          }
   \   00000032   0xBD10             POP      {R4,PC}          ;; return
    199          
    200          /*    uart5  GPRS中断服务函数    */

   \                                 In section .text, align 4, keep-with-next
    201          void uart5_isr(void)
    202          {
   \                     uart5_isr: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    203            int8 recv;
    204            recv = LPLD_UART_GetChar(UART5);
   \   00000002   0x....             LDR.N    R0,??DataTable6_8  ;; 0x400eb000
   \   00000004   0x.... 0x....      BL       LPLD_UART_GetChar
    205            LPLD_UART_PutChar(UART0, recv);
   \   00000008   0x0001             MOVS     R1,R0
   \   0000000A   0xB249             SXTB     R1,R1            ;; SignExt  R1,R1,#+24,#+24
   \   0000000C   0x....             LDR.N    R0,??DataTable6  ;; 0x4006a000
   \   0000000E   0x.... 0x....      BL       LPLD_UART_PutChar
    206            
    207          }
   \   00000012   0xBD01             POP      {R0,PC}          ;; return
    208          
    209          

   \                                 In section .text, align 2, keep-with-next
    210          void cparray (int8 *s, const int8 *fmt, uint8 start,uint8 stop)
    211          {
   \                     cparray: (+1)
   \   00000000   0xB410             PUSH     {R4}
    212            uint16 sto,i=0;
   \   00000002   0x2400             MOVS     R4,#+0
    213            fmt+=start;
   \   00000004   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000006   0x1851             ADDS     R1,R2,R1
    214          //  sto=fmt+stop
    215            
    216              for(i=0;i<stop;i++)
   \   00000008   0x2200             MOVS     R2,#+0
   \   0000000A   0x0014             MOVS     R4,R2
   \   0000000C   0xE004             B.N      ??cparray_0
    217              {
    218                *s++ = *fmt++;
   \                     ??cparray_1: (+1)
   \   0000000E   0x780A             LDRB     R2,[R1, #+0]
   \   00000010   0x7002             STRB     R2,[R0, #+0]
   \   00000012   0x1C49             ADDS     R1,R1,#+1
   \   00000014   0x1C40             ADDS     R0,R0,#+1
    219              }
   \   00000016   0x1C64             ADDS     R4,R4,#+1
   \                     ??cparray_0: (+1)
   \   00000018   0x001A             MOVS     R2,R3
   \   0000001A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000001C   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000001E   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000020   0x4294             CMP      R4,R2
   \   00000022   0xD3F4             BCC.N    ??cparray_1
    220              
    221          }
   \   00000024   0xBC10             POP      {R4}
   \   00000026   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x4006A000         DC32     0x4006a000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x........         DC32     uart0_init_struct

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0x4006B000         DC32     0x4006b000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \   00000000   0x........         DC32     uart1_init_struct

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \   00000000   0x4006D000         DC32     0x4006d000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \   00000000   0x........         DC32     uart3_init_struct

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_6:
   \   00000000   0x400EA000         DC32     0x400ea000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_7:
   \   00000000   0x........         DC32     uart4_init_struct

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_8:
   \   00000000   0x400EB000         DC32     0x400eb000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_9:
   \   00000000   0x........         DC32     uart5_init_struct

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_10:
   \   00000000   0x4006C000         DC32     0x4006c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_11:
   \   00000000   0x........         DC32     step

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_12:
   \   00000000   0x........         DC32     t1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_13:
   \   00000000   0x........         DC32     GPS_HEAD

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_14:
   \   00000000   0x........         DC32     gps_flag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_15:
   \   00000000   0x........         DC32     t3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_16:
   \   00000000   0x........         DC32     gps_gga

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_17:
   \   00000000   0x........         DC32     `?<Constant "GNGGA">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_18:
   \   00000000   0x........         DC32     t2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_19:
   \   00000000   0x........         DC32     test

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_20:
   \   00000000   0x........         DC32     uart_step

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_21:
   \   00000000   0x........         DC32     step_buf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_22:
   \   00000000   0x........         DC32     buf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_23:
   \   00000000   0x........         DC32     test1

   \                                 In section .rodata, align 4
   \                     `?<Constant "GNGGA">`:
   \   00000000   0x47 0x4E          DC8 "GNGGA"
   \              0x47 0x47    
   \              0x41 0x00    
   \   00000006   0x00 0x00          DC8 0, 0
    222          
    223          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       4   cparray
       8   uart0_isr
         8   -> LPLD_UART_GetChar
         8   -> LPLD_UART_PutChar
       8   uart1_isr
         8   -> LPLD_UART_GetChar
         8   -> LPLD_UART_PutChar
       8   uart2_isr
         8   -> LPLD_UART_GetChar
         8   -> LPLD_UART_PutChar
       8   uart3_isr
         8   -> LPLD_UART_GetChar
         8   -> strcmp
       8   uart4_isr
         8   -> LPLD_UART_GetChar
         8   -> LPLD_UART_PutChar
       8   uart5_isr
         8   -> LPLD_UART_GetChar
         8   -> LPLD_UART_PutChar
      24   uart_init
         8   -> LPLD_UART_EnableIrq
         8   -> LPLD_UART_Init
        24   -> __aeabi_memcpy4


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       8  ?<Constant "GNGGA">
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_10
       4  ??DataTable6_11
       4  ??DataTable6_12
       4  ??DataTable6_13
       4  ??DataTable6_14
       4  ??DataTable6_15
       4  ??DataTable6_16
       4  ??DataTable6_17
       4  ??DataTable6_18
       4  ??DataTable6_19
       4  ??DataTable6_2
       4  ??DataTable6_20
       4  ??DataTable6_21
       4  ??DataTable6_22
       4  ??DataTable6_23
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable6_7
       4  ??DataTable6_8
       4  ??DataTable6_9
       1  E
       8  GPS_HEAD
      20  buf
      40  cparray
       1  gps_flag
      80  gps_gga
      80  gps_test
       1  step
       1  step_buf
       1  t1
       1  t2
       1  t3
       1  t4
      80  test
       1  test1
       1  uart0__flag_rev
      20  uart0_init_struct
      20  uart0_isr
     100  uart0_rev
       1  uart1_flag_rev
      20  uart1_init_struct
      20  uart1_isr
     100  uart1_rev
       1  uart2_flag_rev
      20  uart2_init_struct
      20  uart2_isr
     100  uart2_rev
       1  uart3_flag_rev
      20  uart3_init_struct
     180  uart3_isr
     100  uart3_rev
       1  uart4_flag_rev
      20  uart4_init_struct
      52  uart4_isr
     100  uart4_rev
       1  uart5_flag_rev
      20  uart5_init_struct
      20  uart5_isr
     100  uart5_rev
     384  uart_init
       1  uart_step

 
 1 003 bytes in section .bss
     1 byte  in section .data
     8 bytes in section .rodata
   832 bytes in section .text
 
   832 bytes of CODE  memory
     8 bytes of CONST memory
 1 004 bytes of DATA  memory

Errors: none
Warnings: 2
