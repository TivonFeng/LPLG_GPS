###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        23/Apr/2015  14:23:11
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  G:\test\LPLD_OSKinetis_V3_now02\lib\Security\cJSON.c
#    Command line =  
#        G:\test\LPLD_OSKinetis_V3_now02\lib\Security\cJSON.c -D LPLD_K60 -lCN
#        G:\test\LPLD_OSKinetis_V3_now02\project\LPLD_OV7670\iar\FLASH\List\
#        -lB
#        G:\test\LPLD_OSKinetis_V3_now02\project\LPLD_OV7670\iar\FLASH\List\ -o
#        G:\test\LPLD_OSKinetis_V3_now02\project\LPLD_OV7670\iar\FLASH\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=None --dlib_config
#        E:\iar\arm\INC\c\DLib_Config_Normal.h -I
#        G:\test\LPLD_OSKinetis_V3_now02\project\LPLD_OV7670\iar\..\app\ -I
#        G:\test\LPLD_OSKinetis_V3_now02\project\LPLD_OV7670\iar\..\..\..\lib\CPU\
#        -I
#        G:\test\LPLD_OSKinetis_V3_now02\project\LPLD_OV7670\iar\..\..\..\lib\common\
#        -I
#        G:\test\LPLD_OSKinetis_V3_now02\project\LPLD_OV7670\iar\..\..\..\lib\LPLD\
#        -I
#        G:\test\LPLD_OSKinetis_V3_now02\project\LPLD_OV7670\iar\..\..\..\lib\LPLD\HW\
#        -I
#        G:\test\LPLD_OSKinetis_V3_now02\project\LPLD_OV7670\iar\..\..\..\lib\LPLD\DEV\
#        -I
#        G:\test\LPLD_OSKinetis_V3_now02\project\LPLD_OV7670\iar\..\..\..\lib\uCOS-II\Ports\
#        -I
#        G:\test\LPLD_OSKinetis_V3_now02\project\LPLD_OV7670\iar\..\..\..\lib\uCOS-II\Source\
#        -I
#        G:\test\LPLD_OSKinetis_V3_now02\project\LPLD_OV7670\iar\..\..\..\lib\FatFs\
#        -I
#        G:\test\LPLD_OSKinetis_V3_now02\project\LPLD_OV7670\iar\..\..\..\lib\FatFs\option\
#        -I
#        G:\test\LPLD_OSKinetis_V3_now02\project\LPLD_OV7670\iar\..\..\..\lib\USB\common\
#        -I
#        G:\test\LPLD_OSKinetis_V3_now02\project\LPLD_OV7670\iar\..\..\..\lib\USB\driver\
#        -I
#        G:\test\LPLD_OSKinetis_V3_now02\project\LPLD_OV7670\iar\..\..\..\lib\USB\descriptor\
#        -I
#        G:\test\LPLD_OSKinetis_V3_now02\project\LPLD_OV7670\iar\..\..\..\lib\USB\class\
#        -I
#        G:\test\LPLD_OSKinetis_V3_now02\project\LPLD_OV7670\iar\..\..\..\lib\Security\
#        -I
#        G:\test\LPLD_OSKinetis_V3_now02\project\LPLD_OV7670\iar\..\..\..\lib\SQC\
#        -Ol -I E:\iar\arm\CMSIS\Include\ -D ARM_MATH_CM4
#    List file    =  
#        G:\test\LPLD_OSKinetis_V3_now02\project\LPLD_OV7670\iar\FLASH\List\cJSON.lst
#    Object file  =  
#        G:\test\LPLD_OSKinetis_V3_now02\project\LPLD_OV7670\iar\FLASH\Obj\cJSON.o
#
###############################################################################

G:\test\LPLD_OSKinetis_V3_now02\lib\Security\cJSON.c
      1          /*
      2            Copyright (c) 2009 Dave Gamble
      3          
      4            Permission is hereby granted, free of charge, to any person obtaining a copy
      5            of this software and associated documentation files (the "Software"), to deal
      6            in the Software without restriction, including without limitation the rights
      7            to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
      8            copies of the Software, and to permit persons to whom the Software is
      9            furnished to do so, subject to the following conditions:
     10          
     11            The above copyright notice and this permission notice shall be included in
     12            all copies or substantial portions of the Software.
     13          
     14            THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     15            IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     16            FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     17            AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     18            LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     19            OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     20            THE SOFTWARE.
     21          */
     22          
     23          /* cJSON */
     24          /* JSON parser in C. */
     25          
     26          //#include <string.h>
     27          //#include <stdio.h>
     28          #include <math.h>
     29          #include "stdlib.h"
     30          #include <float.h>
     31          #include <limits.h>
     32          #include <ctype.h>
     33          #include "cJSON.h"
     34          

   \                                 In section .bss, align 4
     35          static const char *ep;
   \                     ep:
   \   00000000                      DS8 4
     36          

   \                                 In section .text, align 2, keep-with-next
     37          const char *cJSON_GetErrorPtr(void)
     38          {
     39              return ep;
   \                     cJSON_GetErrorPtr: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable14
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x4770             BX       LR               ;; return
     40          }
     41          

   \                                 In section .text, align 2, keep-with-next
     42          static int cJSON_strcasecmp(const char *s1, const char *s2)
     43          {
   \                     cJSON_strcasecmp: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
     44              if (!s1) return (s1 == s2) ? 0 : 1;
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD105             BNE.N    ??cJSON_strcasecmp_0
   \   0000000A   0x42AC             CMP      R4,R5
   \   0000000C   0xD101             BNE.N    ??cJSON_strcasecmp_1
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xE000             B.N      ??cJSON_strcasecmp_2
   \                     ??cJSON_strcasecmp_1: (+1)
   \   00000012   0x2001             MOVS     R0,#+1
   \                     ??cJSON_strcasecmp_2: (+1)
   \   00000014   0xE01B             B.N      ??cJSON_strcasecmp_3
     45              if (!s2) return 1;
   \                     ??cJSON_strcasecmp_0: (+1)
   \   00000016   0x2D00             CMP      R5,#+0
   \   00000018   0xD103             BNE.N    ??cJSON_strcasecmp_4
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0xE017             B.N      ??cJSON_strcasecmp_3
     46              for(; tolower(*s1) == tolower(*s2); ++s1, ++s2)	if(*s1 == 0)	return 0;
   \                     ??cJSON_strcasecmp_5: (+1)
   \   0000001E   0x1C64             ADDS     R4,R4,#+1
   \   00000020   0x1C6D             ADDS     R5,R5,#+1
   \                     ??cJSON_strcasecmp_4: (+1)
   \   00000022   0x7820             LDRB     R0,[R4, #+0]
   \   00000024   0x.... 0x....      BL       tolower
   \   00000028   0x0006             MOVS     R6,R0
   \   0000002A   0x7828             LDRB     R0,[R5, #+0]
   \   0000002C   0x.... 0x....      BL       tolower
   \   00000030   0x4286             CMP      R6,R0
   \   00000032   0xD104             BNE.N    ??cJSON_strcasecmp_6
   \   00000034   0x7820             LDRB     R0,[R4, #+0]
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD1F1             BNE.N    ??cJSON_strcasecmp_5
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xE007             B.N      ??cJSON_strcasecmp_3
     47              return tolower(*(const unsigned char *)s1) - tolower(*(const unsigned char *)s2);
   \                     ??cJSON_strcasecmp_6: (+1)
   \   0000003E   0x7820             LDRB     R0,[R4, #+0]
   \   00000040   0x.... 0x....      BL       tolower
   \   00000044   0x0004             MOVS     R4,R0
   \   00000046   0x7828             LDRB     R0,[R5, #+0]
   \   00000048   0x.... 0x....      BL       tolower
   \   0000004C   0x1A20             SUBS     R0,R4,R0
   \                     ??cJSON_strcasecmp_3: (+1)
   \   0000004E   0xBD70             POP      {R4-R6,PC}       ;; return
     48          }
     49          

   \                                 In section .data, align 4
     50          static void *(*cJSON_malloc)(size_t sz) = malloc;
   \                     cJSON_malloc:
   \   00000000   0x........         DC32 malloc

   \                                 In section .data, align 4
     51          static void (*cJSON_free)(void *ptr) = free;
   \                     cJSON_free:
   \   00000000   0x........         DC32 free
     52          

   \                                 In section .text, align 2, keep-with-next
     53          static char *cJSON_strdup(const char *str)
     54          {
   \                     cJSON_strdup: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
     55              size_t len;
     56              char *copy;
     57          
     58              len = strlen(str) + 1;
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       strlen
   \   0000000A   0x1C45             ADDS     R5,R0,#+1
     59              if (!(copy = (char *)cJSON_malloc(len))) return 0;
   \   0000000C   0x0028             MOVS     R0,R5
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable14_1
   \   00000012   0x6809             LDR      R1,[R1, #+0]
   \   00000014   0x4788             BLX      R1
   \   00000016   0x0006             MOVS     R6,R0
   \   00000018   0x2E00             CMP      R6,#+0
   \   0000001A   0xD101             BNE.N    ??cJSON_strdup_0
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xE005             B.N      ??cJSON_strdup_1
     60              memcpy(copy, str, len);
   \                     ??cJSON_strdup_0: (+1)
   \   00000020   0x002A             MOVS     R2,R5
   \   00000022   0x0021             MOVS     R1,R4
   \   00000024   0x0030             MOVS     R0,R6
   \   00000026   0x.... 0x....      BL       memcpy
     61              return copy;
   \   0000002A   0x0030             MOVS     R0,R6
   \                     ??cJSON_strdup_1: (+1)
   \   0000002C   0xBD70             POP      {R4-R6,PC}       ;; return
     62          }
     63          

   \                                 In section .text, align 2, keep-with-next
     64          void cJSON_InitHooks(cJSON_Hooks *hooks)
     65          {
     66              if (!hooks)   /* Reset hooks */
   \                     cJSON_InitHooks: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD10A             BNE.N    ??cJSON_InitHooks_0
     67              {
     68                  cJSON_malloc = malloc;
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable14_2
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable14_1
   \   0000000C   0x6008             STR      R0,[R1, #+0]
     69                  cJSON_free = free;
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable14_3
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable14_4
   \   00000016   0x6008             STR      R0,[R1, #+0]
     70                  return;
   \   00000018   0xE019             B.N      ??cJSON_InitHooks_1
     71              }
     72          
     73              cJSON_malloc = (hooks->malloc_fn) ? hooks->malloc_fn : malloc;
   \                     ??cJSON_InitHooks_0: (+1)
   \   0000001A   0x6801             LDR      R1,[R0, #+0]
   \   0000001C   0x2900             CMP      R1,#+0
   \   0000001E   0xD004             BEQ.N    ??cJSON_InitHooks_2
   \   00000020   0x6801             LDR      R1,[R0, #+0]
   \   00000022   0x.... 0x....      LDR.W    R2,??DataTable14_1
   \   00000026   0x6011             STR      R1,[R2, #+0]
   \   00000028   0xE004             B.N      ??cJSON_InitHooks_3
   \                     ??cJSON_InitHooks_2: (+1)
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable14_2
   \   0000002E   0x.... 0x....      LDR.W    R2,??DataTable14_1
   \   00000032   0x6011             STR      R1,[R2, #+0]
     74              cJSON_free	 = (hooks->free_fn) ? hooks->free_fn : free;
   \                     ??cJSON_InitHooks_3: (+1)
   \   00000034   0x6841             LDR      R1,[R0, #+4]
   \   00000036   0x2900             CMP      R1,#+0
   \   00000038   0xD004             BEQ.N    ??cJSON_InitHooks_4
   \   0000003A   0x6840             LDR      R0,[R0, #+4]
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable14_4
   \   00000040   0x6008             STR      R0,[R1, #+0]
   \   00000042   0xE004             B.N      ??cJSON_InitHooks_5
   \                     ??cJSON_InitHooks_4: (+1)
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable14_3
   \   00000048   0x.... 0x....      LDR.W    R1,??DataTable14_4
   \   0000004C   0x6008             STR      R0,[R1, #+0]
     75          }
   \                     ??cJSON_InitHooks_5: (+1)
   \                     ??cJSON_InitHooks_1: (+1)
   \   0000004E   0x4770             BX       LR               ;; return
     76          
     77          /* Internal constructor. */

   \                                 In section .text, align 2, keep-with-next
     78          static cJSON *cJSON_New_Item(void)
     79          {
   \                     cJSON_New_Item: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
     80              cJSON *node = (cJSON *)cJSON_malloc(sizeof(cJSON));
   \   00000002   0x2028             MOVS     R0,#+40
   \   00000004   0x.... 0x....      LDR.W    R1,??DataTable14_1
   \   00000008   0x6809             LDR      R1,[R1, #+0]
   \   0000000A   0x4788             BLX      R1
   \   0000000C   0x0004             MOVS     R4,R0
     81              if (node) memset(node, 0, sizeof(cJSON));
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD004             BEQ.N    ??cJSON_New_Item_0
   \   00000012   0x2228             MOVS     R2,#+40
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0x.... 0x....      BL       memset
     82              return node;
   \                     ??cJSON_New_Item_0: (+1)
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
     83          }
     84          
     85          /* Delete a cJSON structure. */

   \                                 In section .text, align 2, keep-with-next
     86          void cJSON_Delete(cJSON *c)
     87          {
   \                     cJSON_Delete: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0xE025             B.N      ??cJSON_Delete_0
     88              cJSON *next;
     89              while (c)
     90              {
     91                  next = c->next;
   \                     ??cJSON_Delete_1: (+1)
   \   00000006   0x6825             LDR      R5,[R4, #+0]
     92                  if (!(c->type & cJSON_IsReference) && c->child) cJSON_Delete(c->child);
   \   00000008   0x68E0             LDR      R0,[R4, #+12]
   \   0000000A   0x05C0             LSLS     R0,R0,#+23
   \   0000000C   0xD405             BMI.N    ??cJSON_Delete_2
   \   0000000E   0x68A0             LDR      R0,[R4, #+8]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD002             BEQ.N    ??cJSON_Delete_2
   \   00000014   0x68A0             LDR      R0,[R4, #+8]
   \   00000016   0xF7FF 0xFFF3      BL       cJSON_Delete
     93                  if (!(c->type & cJSON_IsReference) && c->valuestring) cJSON_free(c->valuestring);
   \                     ??cJSON_Delete_2: (+1)
   \   0000001A   0x68E0             LDR      R0,[R4, #+12]
   \   0000001C   0x05C0             LSLS     R0,R0,#+23
   \   0000001E   0xD407             BMI.N    ??cJSON_Delete_3
   \   00000020   0x6920             LDR      R0,[R4, #+16]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD004             BEQ.N    ??cJSON_Delete_3
   \   00000026   0x6920             LDR      R0,[R4, #+16]
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable14_4
   \   0000002C   0x6809             LDR      R1,[R1, #+0]
   \   0000002E   0x4788             BLX      R1
     94                  if (!(c->type & cJSON_StringIsConst) && c->string) cJSON_free(c->string);
   \                     ??cJSON_Delete_3: (+1)
   \   00000030   0x68E0             LDR      R0,[R4, #+12]
   \   00000032   0x0580             LSLS     R0,R0,#+22
   \   00000034   0xD407             BMI.N    ??cJSON_Delete_4
   \   00000036   0x6A20             LDR      R0,[R4, #+32]
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD004             BEQ.N    ??cJSON_Delete_4
   \   0000003C   0x6A20             LDR      R0,[R4, #+32]
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable14_4
   \   00000042   0x6809             LDR      R1,[R1, #+0]
   \   00000044   0x4788             BLX      R1
     95                  cJSON_free(c);
   \                     ??cJSON_Delete_4: (+1)
   \   00000046   0x0020             MOVS     R0,R4
   \   00000048   0x.... 0x....      LDR.W    R1,??DataTable14_4
   \   0000004C   0x6809             LDR      R1,[R1, #+0]
   \   0000004E   0x4788             BLX      R1
     96                  c = next;
   \   00000050   0x002C             MOVS     R4,R5
     97              }
   \                     ??cJSON_Delete_0: (+1)
   \   00000052   0x2C00             CMP      R4,#+0
   \   00000054   0xD1D7             BNE.N    ??cJSON_Delete_1
     98          }
   \   00000056   0xBD31             POP      {R0,R4,R5,PC}    ;; return
     99          
    100          /* Parse the input text to generate a number, and populate the result into item. */

   \                                 In section .text, align 2, keep-with-next
    101          static const char *parse_number(cJSON *item, const char *num)
    102          {
   \                     parse_number: (+1)
   \   00000000   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x000E             MOVS     R6,R1
    103              double n = 0, sign = 1, scale = 0;
   \   00000008   0xF05F 0x0800      MOVS     R8,#+0
   \   0000000C   0xF05F 0x0900      MOVS     R9,#+0
   \   00000010   0xF05F 0x0A00      MOVS     R10,#+0
   \   00000014   0x.... 0x....      LDR.W    R11,??DataTable14_5  ;; 0x3ff00000
   \   00000018   0x2400             MOVS     R4,#+0
   \   0000001A   0x2500             MOVS     R5,#+0
    104              int subscale = 0, signsubscale = 1;
   \   0000001C   0x2700             MOVS     R7,#+0
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0x9000             STR      R0,[SP, #+0]
    105          
    106              if (*num == '-') sign = -1, num++;	/* Has sign? */
   \   00000022   0x7830             LDRB     R0,[R6, #+0]
   \   00000024   0x282D             CMP      R0,#+45
   \   00000026   0xD104             BNE.N    ??parse_number_0
   \   00000028   0xF05F 0x0A00      MOVS     R10,#+0
   \   0000002C   0x.... 0x....      LDR.W    R11,??DataTable14_6  ;; 0xbff00000
   \   00000030   0x1C76             ADDS     R6,R6,#+1
    107              if (*num == '0') num++;			/* is zero */
   \                     ??parse_number_0: (+1)
   \   00000032   0x7830             LDRB     R0,[R6, #+0]
   \   00000034   0x2830             CMP      R0,#+48
   \   00000036   0xD100             BNE.N    ??parse_number_1
   \   00000038   0x1C76             ADDS     R6,R6,#+1
    108              if (*num >= '1' && *num <= '9')	do	n = (n * 10.0) + (*num++ -'0');
   \                     ??parse_number_1: (+1)
   \   0000003A   0x7830             LDRB     R0,[R6, #+0]
   \   0000003C   0x3831             SUBS     R0,R0,#+49
   \   0000003E   0x2809             CMP      R0,#+9
   \   00000040   0xD217             BCS.N    ??parse_number_2
   \                     ??parse_number_3: (+1)
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable14_7  ;; 0x40240000
   \   00000048   0x4642             MOV      R2,R8
   \   0000004A   0x464B             MOV      R3,R9
   \   0000004C   0x.... 0x....      BL       __aeabi_dmul
   \   00000050   0x4680             MOV      R8,R0
   \   00000052   0x4689             MOV      R9,R1
   \   00000054   0x7830             LDRB     R0,[R6, #+0]
   \   00000056   0x3830             SUBS     R0,R0,#+48
   \   00000058   0x.... 0x....      BL       __aeabi_i2d
   \   0000005C   0x4642             MOV      R2,R8
   \   0000005E   0x464B             MOV      R3,R9
   \   00000060   0x.... 0x....      BL       __aeabi_dadd
   \   00000064   0x4680             MOV      R8,R0
   \   00000066   0x4689             MOV      R9,R1
   \   00000068   0x1C76             ADDS     R6,R6,#+1
    109                  while (*num >= '0' && *num <= '9');	/* Number? */
   \   0000006A   0x7830             LDRB     R0,[R6, #+0]
   \   0000006C   0x3830             SUBS     R0,R0,#+48
   \   0000006E   0x280A             CMP      R0,#+10
   \   00000070   0xD3E7             BCC.N    ??parse_number_3
    110              if (*num == '.' && num[1] >= '0' && num[1] <= '9')
   \                     ??parse_number_2: (+1)
   \   00000072   0x7830             LDRB     R0,[R6, #+0]
   \   00000074   0x282E             CMP      R0,#+46
   \   00000076   0xD125             BNE.N    ??parse_number_4
   \   00000078   0x7870             LDRB     R0,[R6, #+1]
   \   0000007A   0x3830             SUBS     R0,R0,#+48
   \   0000007C   0x280A             CMP      R0,#+10
   \   0000007E   0xD221             BCS.N    ??parse_number_4
    111              {
    112                  num++;		   /* Fractional part? */
   \   00000080   0x1C76             ADDS     R6,R6,#+1
    113                  do	n = (n * 10.0) + (*num++ -'0'), scale--;
   \                     ??parse_number_5: (+1)
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0x.... 0x....      LDR.W    R1,??DataTable14_7  ;; 0x40240000
   \   00000088   0x4642             MOV      R2,R8
   \   0000008A   0x464B             MOV      R3,R9
   \   0000008C   0x.... 0x....      BL       __aeabi_dmul
   \   00000090   0x4680             MOV      R8,R0
   \   00000092   0x4689             MOV      R9,R1
   \   00000094   0x7830             LDRB     R0,[R6, #+0]
   \   00000096   0x3830             SUBS     R0,R0,#+48
   \   00000098   0x.... 0x....      BL       __aeabi_i2d
   \   0000009C   0x4642             MOV      R2,R8
   \   0000009E   0x464B             MOV      R3,R9
   \   000000A0   0x.... 0x....      BL       __aeabi_dadd
   \   000000A4   0x4680             MOV      R8,R0
   \   000000A6   0x4689             MOV      R9,R1
   \   000000A8   0x1C76             ADDS     R6,R6,#+1
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0x.... 0x....      LDR.W    R1,??DataTable14_6  ;; 0xbff00000
   \   000000B0   0x0022             MOVS     R2,R4
   \   000000B2   0x002B             MOVS     R3,R5
   \   000000B4   0x.... 0x....      BL       __aeabi_dadd
   \   000000B8   0x0004             MOVS     R4,R0
   \   000000BA   0x000D             MOVS     R5,R1
    114                  while (*num >= '0' && *num <= '9');
   \   000000BC   0x7830             LDRB     R0,[R6, #+0]
   \   000000BE   0x3830             SUBS     R0,R0,#+48
   \   000000C0   0x280A             CMP      R0,#+10
   \   000000C2   0xD3DE             BCC.N    ??parse_number_5
    115              }
    116              if (*num == 'e' || *num == 'E')		/* Exponent? */
   \                     ??parse_number_4: (+1)
   \   000000C4   0x7830             LDRB     R0,[R6, #+0]
   \   000000C6   0x2865             CMP      R0,#+101
   \   000000C8   0xD002             BEQ.N    ??parse_number_6
   \   000000CA   0x7830             LDRB     R0,[R6, #+0]
   \   000000CC   0x2845             CMP      R0,#+69
   \   000000CE   0xD118             BNE.N    ??parse_number_7
    117              {
    118                  num++;
   \                     ??parse_number_6: (+1)
   \   000000D0   0x1C76             ADDS     R6,R6,#+1
    119                  if (*num == '+') num++;
   \   000000D2   0x7830             LDRB     R0,[R6, #+0]
   \   000000D4   0x282B             CMP      R0,#+43
   \   000000D6   0xD101             BNE.N    ??parse_number_8
   \   000000D8   0x1C76             ADDS     R6,R6,#+1
   \   000000DA   0xE00E             B.N      ??parse_number_9
    120                  else if (*num == '-') signsubscale = -1, num++;		/* With sign? */
   \                     ??parse_number_8: (+1)
   \   000000DC   0x7830             LDRB     R0,[R6, #+0]
   \   000000DE   0x282D             CMP      R0,#+45
   \   000000E0   0xD10B             BNE.N    ??parse_number_9
   \   000000E2   0xF05F 0x30FF      MOVS     R0,#-1
   \   000000E6   0x9000             STR      R0,[SP, #+0]
   \   000000E8   0x1C76             ADDS     R6,R6,#+1
   \   000000EA   0xE006             B.N      ??parse_number_9
    121                  while (*num >= '0' && *num <= '9') subscale = (subscale * 10) + (*num++ - '0');	/* Number? */
   \                     ??parse_number_10: (+1)
   \   000000EC   0x200A             MOVS     R0,#+10
   \   000000EE   0x7831             LDRB     R1,[R6, #+0]
   \   000000F0   0xFB00 0x1007      MLA      R0,R0,R7,R1
   \   000000F4   0xF1B0 0x0730      SUBS     R7,R0,#+48
   \   000000F8   0x1C76             ADDS     R6,R6,#+1
   \                     ??parse_number_9: (+1)
   \   000000FA   0x7830             LDRB     R0,[R6, #+0]
   \   000000FC   0x3830             SUBS     R0,R0,#+48
   \   000000FE   0x280A             CMP      R0,#+10
   \   00000100   0xD3F4             BCC.N    ??parse_number_10
    122              }
    123          
    124              n = sign * n * pow(10.0, (scale + subscale * signsubscale));	/* number = +/- number.fraction * 10^+/- exponent */
   \                     ??parse_number_7: (+1)
   \   00000102   0x4642             MOV      R2,R8
   \   00000104   0x464B             MOV      R3,R9
   \   00000106   0x4650             MOV      R0,R10
   \   00000108   0x4659             MOV      R1,R11
   \   0000010A   0x.... 0x....      BL       __aeabi_dmul
   \   0000010E   0x4680             MOV      R8,R0
   \   00000110   0x4689             MOV      R9,R1
   \   00000112   0x9800             LDR      R0,[SP, #+0]
   \   00000114   0xFB00 0xF007      MUL      R0,R0,R7
   \   00000118   0x.... 0x....      BL       __aeabi_i2d
   \   0000011C   0x0022             MOVS     R2,R4
   \   0000011E   0x002B             MOVS     R3,R5
   \   00000120   0x.... 0x....      BL       __aeabi_dadd
   \   00000124   0x0002             MOVS     R2,R0
   \   00000126   0x000B             MOVS     R3,R1
   \   00000128   0x2000             MOVS     R0,#+0
   \   0000012A   0x.... 0x....      LDR.W    R1,??DataTable14_7  ;; 0x40240000
   \   0000012E   0x.... 0x....      BL       pow
   \   00000132   0x4642             MOV      R2,R8
   \   00000134   0x464B             MOV      R3,R9
   \   00000136   0x.... 0x....      BL       __aeabi_dmul
   \   0000013A   0x4680             MOV      R8,R0
   \   0000013C   0x4689             MOV      R9,R1
    125          
    126              item->valuedouble = n;
   \   0000013E   0x9802             LDR      R0,[SP, #+8]
   \   00000140   0xE9C0 0x8906      STRD     R8,R9,[R0, #+24]
    127              item->valueint = (int)n;
   \   00000144   0x4640             MOV      R0,R8
   \   00000146   0x4649             MOV      R1,R9
   \   00000148   0x.... 0x....      BL       __aeabi_d2iz
   \   0000014C   0x9902             LDR      R1,[SP, #+8]
   \   0000014E   0x6148             STR      R0,[R1, #+20]
    128              item->type = cJSON_Number;
   \   00000150   0x2003             MOVS     R0,#+3
   \   00000152   0x9902             LDR      R1,[SP, #+8]
   \   00000154   0x60C8             STR      R0,[R1, #+12]
    129              return num;
   \   00000156   0x0030             MOVS     R0,R6
   \   00000158   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
    130          }
    131          

   \                                 In section .text, align 2, keep-with-next
    132          static int pow2gt (int x)
    133          {
    134              --x;
   \                     pow2gt: (+1)
   \   00000000   0x1E40             SUBS     R0,R0,#+1
    135              x |= x >> 1;
   \   00000002   0xEA50 0x0060      ORRS     R0,R0,R0, ASR #+1
    136              x |= x >> 2;
   \   00000006   0xEA50 0x00A0      ORRS     R0,R0,R0, ASR #+2
    137              x |= x >> 4;
   \   0000000A   0xEA50 0x1020      ORRS     R0,R0,R0, ASR #+4
    138              x |= x >> 8;
   \   0000000E   0xEA50 0x2020      ORRS     R0,R0,R0, ASR #+8
    139              x |= x >> 16;
   \   00000012   0xEA50 0x4020      ORRS     R0,R0,R0, ASR #+16
    140              return x + 1;
   \   00000016   0x1C40             ADDS     R0,R0,#+1
   \   00000018   0x4770             BX       LR               ;; return
    141          }
    142          
    143          typedef struct
    144          {
    145              char *buffer;
    146              int length;
    147              int offset;
    148          } printbuffer;
    149          

   \                                 In section .text, align 2, keep-with-next
    150          static char *ensure(printbuffer *p, int needed)
    151          {
   \                     ensure: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0008             MOVS     R0,R1
    152              char *newbuffer;
    153              int newsize;
    154              if (!p || !p->buffer) return 0;
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD002             BEQ.N    ??ensure_0
   \   0000000A   0x6821             LDR      R1,[R4, #+0]
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD101             BNE.N    ??ensure_1
   \                     ??ensure_0: (+1)
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xE02E             B.N      ??ensure_2
    155              needed += p->offset;
   \                     ??ensure_1: (+1)
   \   00000014   0x68A1             LDR      R1,[R4, #+8]
   \   00000016   0x1808             ADDS     R0,R1,R0
    156              if (needed <= p->length) return p->buffer + p->offset;
   \   00000018   0x6861             LDR      R1,[R4, #+4]
   \   0000001A   0x4281             CMP      R1,R0
   \   0000001C   0xDB03             BLT.N    ??ensure_3
   \   0000001E   0x68A0             LDR      R0,[R4, #+8]
   \   00000020   0x6821             LDR      R1,[R4, #+0]
   \   00000022   0x1840             ADDS     R0,R0,R1
   \   00000024   0xE025             B.N      ??ensure_2
    157          
    158              newsize = pow2gt(needed);
   \                     ??ensure_3: (+1)
   \   00000026   0x.... 0x....      BL       pow2gt
   \   0000002A   0x0006             MOVS     R6,R0
    159              newbuffer = (char *)cJSON_malloc(newsize);
   \   0000002C   0x0030             MOVS     R0,R6
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable14_1
   \   00000032   0x6809             LDR      R1,[R1, #+0]
   \   00000034   0x4788             BLX      R1
   \   00000036   0x0005             MOVS     R5,R0
    160              if (!newbuffer)
   \   00000038   0x2D00             CMP      R5,#+0
   \   0000003A   0xD10A             BNE.N    ??ensure_4
    161              {
    162                  cJSON_free(p->buffer);
   \   0000003C   0x6820             LDR      R0,[R4, #+0]
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable14_4
   \   00000042   0x6809             LDR      R1,[R1, #+0]
   \   00000044   0x4788             BLX      R1
    163                  p->length = 0, p->buffer = 0;
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x6060             STR      R0,[R4, #+4]
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x6020             STR      R0,[R4, #+0]
    164                  return 0;
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xE00F             B.N      ??ensure_2
    165              }
    166              if (newbuffer) memcpy(newbuffer, p->buffer, p->length);
   \                     ??ensure_4: (+1)
   \   00000052   0x2D00             CMP      R5,#+0
   \   00000054   0xD004             BEQ.N    ??ensure_5
   \   00000056   0x6862             LDR      R2,[R4, #+4]
   \   00000058   0x6821             LDR      R1,[R4, #+0]
   \   0000005A   0x0028             MOVS     R0,R5
   \   0000005C   0x.... 0x....      BL       memcpy
    167              cJSON_free(p->buffer);
   \                     ??ensure_5: (+1)
   \   00000060   0x6820             LDR      R0,[R4, #+0]
   \   00000062   0x.... 0x....      LDR.W    R1,??DataTable14_4
   \   00000066   0x6809             LDR      R1,[R1, #+0]
   \   00000068   0x4788             BLX      R1
    168              p->length = newsize;
   \   0000006A   0x6066             STR      R6,[R4, #+4]
    169              p->buffer = newbuffer;
   \   0000006C   0x6025             STR      R5,[R4, #+0]
    170              return newbuffer + p->offset;
   \   0000006E   0x68A0             LDR      R0,[R4, #+8]
   \   00000070   0x1940             ADDS     R0,R0,R5
   \                     ??ensure_2: (+1)
   \   00000072   0xBD70             POP      {R4-R6,PC}       ;; return
    171          }
    172          

   \                                 In section .text, align 2, keep-with-next
    173          static int update(printbuffer *p)
    174          {
   \                     update: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    175              char *str;
    176              if (!p || !p->buffer) return 0;
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD002             BEQ.N    ??update_0
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xD101             BNE.N    ??update_1
   \                     ??update_0: (+1)
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xE007             B.N      ??update_2
    177              str = p->buffer + p->offset;
   \                     ??update_1: (+1)
   \   00000010   0x6881             LDR      R1,[R0, #+8]
   \   00000012   0x6802             LDR      R2,[R0, #+0]
   \   00000014   0x1889             ADDS     R1,R1,R2
    178              return p->offset + strlen(str);
   \   00000016   0x6884             LDR      R4,[R0, #+8]
   \   00000018   0x0008             MOVS     R0,R1
   \   0000001A   0x.... 0x....      BL       strlen
   \   0000001E   0x1900             ADDS     R0,R0,R4
   \                     ??update_2: (+1)
   \   00000020   0xBD10             POP      {R4,PC}          ;; return
    179          }
    180          
    181          /* Render the number nicely from the given item into a string. */

   \                                 In section .text, align 2, keep-with-next
    182          static char *print_number(cJSON *item, printbuffer *p)
    183          {
   \                     print_number: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4680             MOV      R8,R0
   \   00000006   0x000E             MOVS     R6,R1
    184              char *str = 0;
   \   00000008   0x2700             MOVS     R7,#+0
    185              double d = item->valuedouble;
   \   0000000A   0xE9D8 0x4506      LDRD     R4,R5,[R8, #+24]
    186              if (d == 0)
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x0022             MOVS     R2,R4
   \   00000014   0x002B             MOVS     R3,R5
   \   00000016   0x.... 0x....      BL       __aeabi_cdcmpeq
   \   0000001A   0xD115             BNE.N    ??print_number_0
    187              {
    188                  if (p)	str = ensure(p, 2);
   \   0000001C   0x2E00             CMP      R6,#+0
   \   0000001E   0xD005             BEQ.N    ??print_number_1
   \   00000020   0x2102             MOVS     R1,#+2
   \   00000022   0x0030             MOVS     R0,R6
   \   00000024   0x.... 0x....      BL       ensure
   \   00000028   0x0007             MOVS     R7,R0
   \   0000002A   0xE005             B.N      ??print_number_2
    189                  else	str = (char *)cJSON_malloc(2);	/* special case for 0. */
   \                     ??print_number_1: (+1)
   \   0000002C   0x2002             MOVS     R0,#+2
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable14_1
   \   00000032   0x6809             LDR      R1,[R1, #+0]
   \   00000034   0x4788             BLX      R1
   \   00000036   0x0007             MOVS     R7,R0
    190                  if (str) strcpy(str, "0");
   \                     ??print_number_2: (+1)
   \   00000038   0x2F00             CMP      R7,#+0
   \   0000003A   0xF000 0x8092      BEQ.W    ??print_number_3
   \   0000003E   0x....             ADR.N    R1,??DataTable7  ;; "0"
   \   00000040   0x0038             MOVS     R0,R7
   \   00000042   0x.... 0x....      BL       strcpy
   \   00000046   0xE08C             B.N      ??print_number_3
    191              }
    192              else if (fabs(((double)item->valueint) - d) <= DBL_EPSILON && d <= INT_MAX && d >= INT_MIN)
   \                     ??print_number_0: (+1)
   \   00000048   0xF8D8 0x0014      LDR      R0,[R8, #+20]
   \   0000004C   0x.... 0x....      BL       __aeabi_i2d
   \   00000050   0x0022             MOVS     R2,R4
   \   00000052   0x002B             MOVS     R3,R5
   \   00000054   0x.... 0x....      BL       __aeabi_dsub
   \   00000058   0xF031 0x4100      BICS     R1,R1,#0x80000000
   \   0000005C   0x2201             MOVS     R2,#+1
   \   0000005E   0x.... 0x....      LDR.W    R3,??DataTable16  ;; 0x3cb00000
   \   00000062   0x.... 0x....      BL       __aeabi_cdcmple
   \   00000066   0xD227             BCS.N    ??print_number_4
   \   00000068   0x0020             MOVS     R0,R4
   \   0000006A   0x0029             MOVS     R1,R5
   \   0000006C   0x.... 0x....      LDR.W    R2,??DataTable16_1  ;; 0xffc00001
   \   00000070   0x.... 0x....      LDR.W    R3,??DataTable16_2  ;; 0x41dfffff
   \   00000074   0x.... 0x....      BL       __aeabi_cdcmple
   \   00000078   0xD21E             BCS.N    ??print_number_4
   \   0000007A   0x0020             MOVS     R0,R4
   \   0000007C   0x0029             MOVS     R1,R5
   \   0000007E   0x2200             MOVS     R2,#+0
   \   00000080   0x.... 0x....      LDR.W    R3,??DataTable16_3  ;; 0xc1e00000
   \   00000084   0x.... 0x....      BL       __aeabi_cdrcmple
   \   00000088   0xD816             BHI.N    ??print_number_4
    193              {
    194                  if (p)	str = ensure(p, 21);
   \   0000008A   0x2E00             CMP      R6,#+0
   \   0000008C   0xD005             BEQ.N    ??print_number_5
   \   0000008E   0x2115             MOVS     R1,#+21
   \   00000090   0x0030             MOVS     R0,R6
   \   00000092   0x.... 0x....      BL       ensure
   \   00000096   0x0007             MOVS     R7,R0
   \   00000098   0xE005             B.N      ??print_number_6
    195                  else	str = (char *)cJSON_malloc(21);	/* 2^64+1 can be represented in 21 chars. */
   \                     ??print_number_5: (+1)
   \   0000009A   0x2015             MOVS     R0,#+21
   \   0000009C   0x.... 0x....      LDR.W    R1,??DataTable14_1
   \   000000A0   0x6809             LDR      R1,[R1, #+0]
   \   000000A2   0x4788             BLX      R1
   \   000000A4   0x0007             MOVS     R7,R0
    196                  if (str)	sprintf(str, "%d", item->valueint);
   \                     ??print_number_6: (+1)
   \   000000A6   0x2F00             CMP      R7,#+0
   \   000000A8   0xD05B             BEQ.N    ??print_number_3
   \   000000AA   0xF8D8 0x2014      LDR      R2,[R8, #+20]
   \   000000AE   0x....             ADR.N    R1,??DataTable7_1  ;; 0x25, 0x64, 0x00, 0x00
   \   000000B0   0x0038             MOVS     R0,R7
   \   000000B2   0x.... 0x....      BL       sprintf
   \   000000B6   0xE054             B.N      ??print_number_3
    197              }
    198              else
    199              {
    200                  if (p)	str = ensure(p, 64);
   \                     ??print_number_4: (+1)
   \   000000B8   0x2E00             CMP      R6,#+0
   \   000000BA   0xD005             BEQ.N    ??print_number_7
   \   000000BC   0x2140             MOVS     R1,#+64
   \   000000BE   0x0030             MOVS     R0,R6
   \   000000C0   0x.... 0x....      BL       ensure
   \   000000C4   0x0007             MOVS     R7,R0
   \   000000C6   0xE005             B.N      ??print_number_8
    201                  else	str = (char *)cJSON_malloc(64);	/* This is a nice tradeoff. */
   \                     ??print_number_7: (+1)
   \   000000C8   0x2040             MOVS     R0,#+64
   \   000000CA   0x.... 0x....      LDR.W    R1,??DataTable14_1
   \   000000CE   0x6809             LDR      R1,[R1, #+0]
   \   000000D0   0x4788             BLX      R1
   \   000000D2   0x0007             MOVS     R7,R0
    202                  if (str)
   \                     ??print_number_8: (+1)
   \   000000D4   0x2F00             CMP      R7,#+0
   \   000000D6   0xD044             BEQ.N    ??print_number_3
    203                  {
    204                      if (fabs(floor(d) - d) <= DBL_EPSILON && fabs(d) < 1.0e60)sprintf(str, "%.0f", d);
   \   000000D8   0x0020             MOVS     R0,R4
   \   000000DA   0x0029             MOVS     R1,R5
   \   000000DC   0x.... 0x....      BL       floor
   \   000000E0   0x0022             MOVS     R2,R4
   \   000000E2   0x002B             MOVS     R3,R5
   \   000000E4   0x.... 0x....      BL       __aeabi_dsub
   \   000000E8   0xF031 0x4100      BICS     R1,R1,#0x80000000
   \   000000EC   0x2201             MOVS     R2,#+1
   \   000000EE   0x.... 0x....      LDR.W    R3,??DataTable16  ;; 0x3cb00000
   \   000000F2   0x.... 0x....      BL       __aeabi_cdcmple
   \   000000F6   0xD212             BCS.N    ??print_number_9
   \   000000F8   0x0020             MOVS     R0,R4
   \   000000FA   0x0029             MOVS     R1,R5
   \   000000FC   0xF031 0x4100      BICS     R1,R1,#0x80000000
   \   00000100   0x.... 0x....      LDR.W    R2,??DataTable16_4  ;; 0xe4c2f344
   \   00000104   0x.... 0x....      LDR.W    R3,??DataTable16_5  ;; 0x4c63e9e4
   \   00000108   0x.... 0x....      BL       __aeabi_cdcmple
   \   0000010C   0xD207             BCS.N    ??print_number_9
   \   0000010E   0x0022             MOVS     R2,R4
   \   00000110   0x002B             MOVS     R3,R5
   \   00000112   0x.... 0x....      LDR.W    R1,??DataTable16_6
   \   00000116   0x0038             MOVS     R0,R7
   \   00000118   0x.... 0x....      BL       sprintf
   \   0000011C   0xE021             B.N      ??print_number_3
    205                      else if (fabs(d) < 1.0e-6 || fabs(d) > 1.0e9)			sprintf(str, "%e", d);
   \                     ??print_number_9: (+1)
   \   0000011E   0x0020             MOVS     R0,R4
   \   00000120   0x0029             MOVS     R1,R5
   \   00000122   0xF031 0x4100      BICS     R1,R1,#0x80000000
   \   00000126   0x.... 0x....      LDR.W    R2,??DataTable16_7  ;; 0xa0b5ed8d
   \   0000012A   0x.... 0x....      LDR.W    R3,??DataTable16_8  ;; 0x3eb0c6f7
   \   0000012E   0x.... 0x....      BL       __aeabi_cdcmple
   \   00000132   0xD309             BCC.N    ??print_number_10
   \   00000134   0x0020             MOVS     R0,R4
   \   00000136   0x0029             MOVS     R1,R5
   \   00000138   0xF031 0x4100      BICS     R1,R1,#0x80000000
   \   0000013C   0x2201             MOVS     R2,#+1
   \   0000013E   0x.... 0x....      LDR.W    R3,??DataTable16_9  ;; 0x41cdcd65
   \   00000142   0x.... 0x....      BL       __aeabi_cdrcmple
   \   00000146   0xD806             BHI.N    ??print_number_11
   \                     ??print_number_10: (+1)
   \   00000148   0x0022             MOVS     R2,R4
   \   0000014A   0x002B             MOVS     R3,R5
   \   0000014C   0x....             ADR.N    R1,??DataTable8  ;; 0x25, 0x65, 0x00, 0x00
   \   0000014E   0x0038             MOVS     R0,R7
   \   00000150   0x.... 0x....      BL       sprintf
   \   00000154   0xE005             B.N      ??print_number_3
    206                      else												sprintf(str, "%f", d);
   \                     ??print_number_11: (+1)
   \   00000156   0x0022             MOVS     R2,R4
   \   00000158   0x002B             MOVS     R3,R5
   \   0000015A   0x....             ADR.N    R1,??DataTable8_1  ;; 0x25, 0x66, 0x00, 0x00
   \   0000015C   0x0038             MOVS     R0,R7
   \   0000015E   0x.... 0x....      BL       sprintf
    207                  }
    208              }
    209              return str;
   \                     ??print_number_3: (+1)
   \   00000162   0x0038             MOVS     R0,R7
   \   00000164   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    210          }
    211          

   \                                 In section .text, align 2, keep-with-next
    212          static unsigned parse_hex4(const char *str)
    213          {
   \                     parse_hex4: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    214              unsigned h = 0;
   \   00000002   0x2000             MOVS     R0,#+0
    215              if (*str >= '0' && *str <= '9') h += (*str) - '0';
   \   00000004   0x780A             LDRB     R2,[R1, #+0]
   \   00000006   0x3A30             SUBS     R2,R2,#+48
   \   00000008   0x2A0A             CMP      R2,#+10
   \   0000000A   0xD21E             BCS.N    ??parse_hex4_0
   \   0000000C   0x780A             LDRB     R2,[R1, #+0]
   \   0000000E   0x3A30             SUBS     R2,R2,#+48
   \   00000010   0x1810             ADDS     R0,R2,R0
    216              else if (*str >= 'A' && *str <= 'F') h += 10 + (*str) - 'A';
    217              else if (*str >= 'a' && *str <= 'f') h += 10 + (*str) - 'a';
    218              else return 0;
    219              h = h << 4;
   \                     ??parse_hex4_1: (+1)
   \   00000012   0x0100             LSLS     R0,R0,#+4
    220              str++;
   \   00000014   0x1C49             ADDS     R1,R1,#+1
    221              if (*str >= '0' && *str <= '9') h += (*str) - '0';
   \   00000016   0x780A             LDRB     R2,[R1, #+0]
   \   00000018   0x3A30             SUBS     R2,R2,#+48
   \   0000001A   0x2A0A             CMP      R2,#+10
   \   0000001C   0xD227             BCS.N    ??parse_hex4_2
   \   0000001E   0x780A             LDRB     R2,[R1, #+0]
   \   00000020   0x3A30             SUBS     R2,R2,#+48
   \   00000022   0x1810             ADDS     R0,R2,R0
    222              else if (*str >= 'A' && *str <= 'F') h += 10 + (*str) - 'A';
    223              else if (*str >= 'a' && *str <= 'f') h += 10 + (*str) - 'a';
    224              else return 0;
    225              h = h << 4;
   \                     ??parse_hex4_3: (+1)
   \   00000024   0x0100             LSLS     R0,R0,#+4
    226              str++;
   \   00000026   0x1C49             ADDS     R1,R1,#+1
    227              if (*str >= '0' && *str <= '9') h += (*str) - '0';
   \   00000028   0x780A             LDRB     R2,[R1, #+0]
   \   0000002A   0x3A30             SUBS     R2,R2,#+48
   \   0000002C   0x2A0A             CMP      R2,#+10
   \   0000002E   0xD230             BCS.N    ??parse_hex4_4
   \   00000030   0x780A             LDRB     R2,[R1, #+0]
   \   00000032   0x3A30             SUBS     R2,R2,#+48
   \   00000034   0x1810             ADDS     R0,R2,R0
    228              else if (*str >= 'A' && *str <= 'F') h += 10 + (*str) - 'A';
    229              else if (*str >= 'a' && *str <= 'f') h += 10 + (*str) - 'a';
    230              else return 0;
    231              h = h << 4;
   \                     ??parse_hex4_5: (+1)
   \   00000036   0x0100             LSLS     R0,R0,#+4
    232              str++;
   \   00000038   0x1C49             ADDS     R1,R1,#+1
    233              if (*str >= '0' && *str <= '9') h += (*str) - '0';
   \   0000003A   0x780A             LDRB     R2,[R1, #+0]
   \   0000003C   0x3A30             SUBS     R2,R2,#+48
   \   0000003E   0x2A0A             CMP      R2,#+10
   \   00000040   0xD239             BCS.N    ??parse_hex4_6
   \   00000042   0x7809             LDRB     R1,[R1, #+0]
   \   00000044   0x3930             SUBS     R1,R1,#+48
   \   00000046   0x1808             ADDS     R0,R1,R0
    234              else if (*str >= 'A' && *str <= 'F') h += 10 + (*str) - 'A';
    235              else if (*str >= 'a' && *str <= 'f') h += 10 + (*str) - 'a';
    236              else return 0;
    237              return h;
   \                     ??parse_hex4_7: (+1)
   \                     ??parse_hex4_8: (+1)
   \   00000048   0x4770             BX       LR               ;; return
   \                     ??parse_hex4_0: (+1)
   \   0000004A   0x780A             LDRB     R2,[R1, #+0]
   \   0000004C   0x3A41             SUBS     R2,R2,#+65
   \   0000004E   0x2A06             CMP      R2,#+6
   \   00000050   0xD203             BCS.N    ??parse_hex4_9
   \   00000052   0x780A             LDRB     R2,[R1, #+0]
   \   00000054   0x3A37             SUBS     R2,R2,#+55
   \   00000056   0x1810             ADDS     R0,R2,R0
   \   00000058   0xE7DB             B.N      ??parse_hex4_1
   \                     ??parse_hex4_9: (+1)
   \   0000005A   0x780A             LDRB     R2,[R1, #+0]
   \   0000005C   0x3A61             SUBS     R2,R2,#+97
   \   0000005E   0x2A06             CMP      R2,#+6
   \   00000060   0xD203             BCS.N    ??parse_hex4_10
   \   00000062   0x780A             LDRB     R2,[R1, #+0]
   \   00000064   0x3A57             SUBS     R2,R2,#+87
   \   00000066   0x1810             ADDS     R0,R2,R0
   \   00000068   0xE7D3             B.N      ??parse_hex4_1
   \                     ??parse_hex4_10: (+1)
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0xE7EC             B.N      ??parse_hex4_8
   \                     ??parse_hex4_2: (+1)
   \   0000006E   0x780A             LDRB     R2,[R1, #+0]
   \   00000070   0x3A41             SUBS     R2,R2,#+65
   \   00000072   0x2A06             CMP      R2,#+6
   \   00000074   0xD203             BCS.N    ??parse_hex4_11
   \   00000076   0x780A             LDRB     R2,[R1, #+0]
   \   00000078   0x3A37             SUBS     R2,R2,#+55
   \   0000007A   0x1810             ADDS     R0,R2,R0
   \   0000007C   0xE7D2             B.N      ??parse_hex4_3
   \                     ??parse_hex4_11: (+1)
   \   0000007E   0x780A             LDRB     R2,[R1, #+0]
   \   00000080   0x3A61             SUBS     R2,R2,#+97
   \   00000082   0x2A06             CMP      R2,#+6
   \   00000084   0xD203             BCS.N    ??parse_hex4_12
   \   00000086   0x780A             LDRB     R2,[R1, #+0]
   \   00000088   0x3A57             SUBS     R2,R2,#+87
   \   0000008A   0x1810             ADDS     R0,R2,R0
   \   0000008C   0xE7CA             B.N      ??parse_hex4_3
   \                     ??parse_hex4_12: (+1)
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0xE7DA             B.N      ??parse_hex4_8
   \                     ??parse_hex4_4: (+1)
   \   00000092   0x780A             LDRB     R2,[R1, #+0]
   \   00000094   0x3A41             SUBS     R2,R2,#+65
   \   00000096   0x2A06             CMP      R2,#+6
   \   00000098   0xD203             BCS.N    ??parse_hex4_13
   \   0000009A   0x780A             LDRB     R2,[R1, #+0]
   \   0000009C   0x3A37             SUBS     R2,R2,#+55
   \   0000009E   0x1810             ADDS     R0,R2,R0
   \   000000A0   0xE7C9             B.N      ??parse_hex4_5
   \                     ??parse_hex4_13: (+1)
   \   000000A2   0x780A             LDRB     R2,[R1, #+0]
   \   000000A4   0x3A61             SUBS     R2,R2,#+97
   \   000000A6   0x2A06             CMP      R2,#+6
   \   000000A8   0xD203             BCS.N    ??parse_hex4_14
   \   000000AA   0x780A             LDRB     R2,[R1, #+0]
   \   000000AC   0x3A57             SUBS     R2,R2,#+87
   \   000000AE   0x1810             ADDS     R0,R2,R0
   \   000000B0   0xE7C1             B.N      ??parse_hex4_5
   \                     ??parse_hex4_14: (+1)
   \   000000B2   0x2000             MOVS     R0,#+0
   \   000000B4   0xE7C8             B.N      ??parse_hex4_8
   \                     ??parse_hex4_6: (+1)
   \   000000B6   0x780A             LDRB     R2,[R1, #+0]
   \   000000B8   0x3A41             SUBS     R2,R2,#+65
   \   000000BA   0x2A06             CMP      R2,#+6
   \   000000BC   0xD203             BCS.N    ??parse_hex4_15
   \   000000BE   0x7809             LDRB     R1,[R1, #+0]
   \   000000C0   0x3937             SUBS     R1,R1,#+55
   \   000000C2   0x1808             ADDS     R0,R1,R0
   \   000000C4   0xE7C0             B.N      ??parse_hex4_7
   \                     ??parse_hex4_15: (+1)
   \   000000C6   0x780A             LDRB     R2,[R1, #+0]
   \   000000C8   0x3A61             SUBS     R2,R2,#+97
   \   000000CA   0x2A06             CMP      R2,#+6
   \   000000CC   0xD203             BCS.N    ??parse_hex4_16
   \   000000CE   0x7809             LDRB     R1,[R1, #+0]
   \   000000D0   0x3957             SUBS     R1,R1,#+87
   \   000000D2   0x1808             ADDS     R0,R1,R0
   \   000000D4   0xE7B8             B.N      ??parse_hex4_7
   \                     ??parse_hex4_16: (+1)
   \   000000D6   0x2000             MOVS     R0,#+0
   \   000000D8   0xE7B6             B.N      ??parse_hex4_8
    238          }
    239          
    240          /* Parse the input text into an unescaped cstring, and populate item. */

   \                                 In section .rodata, align 4
    241          static const unsigned char firstByteMark[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };
   \                     firstByteMark:
   \   00000000   0x00 0x00          DC8 0, 0, 192, 224, 240, 248, 252, 0
   \              0xC0 0xE0    
   \              0xF0 0xF8    
   \              0xFC 0x00    

   \                                 In section .text, align 2, keep-with-next
    242          static const char *parse_string(cJSON *item, const char *str)
    243          {
   \                     parse_string: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000E             MOVS     R6,R1
    244              const char *ptr = str + 1;
   \   00000008   0x1C75             ADDS     R5,R6,#+1
    245              char *ptr2;
    246              char *out;
    247              int len = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
    248              unsigned uc, uc2;
    249              if (*str != '\"')
   \   0000000C   0x7831             LDRB     R1,[R6, #+0]
   \   0000000E   0x2922             CMP      R1,#+34
   \   00000010   0xD00A             BEQ.N    ??parse_string_0
    250              {
    251                  ep = str;    /* not a string! */
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable14
   \   00000016   0x6006             STR      R6,[R0, #+0]
    252                  return 0;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xE0C2             B.N      ??parse_string_1
    253              }
    254          
    255              while (*ptr != '\"' && *ptr && ++len) if (*ptr++ == '\\') ptr++;	/* Skip escaped quotes. */
   \                     ??parse_string_2: (+1)
   \   0000001C   0x0029             MOVS     R1,R5
   \   0000001E   0x1C4D             ADDS     R5,R1,#+1
   \   00000020   0x7809             LDRB     R1,[R1, #+0]
   \   00000022   0x295C             CMP      R1,#+92
   \   00000024   0xD100             BNE.N    ??parse_string_0
   \   00000026   0x1C6D             ADDS     R5,R5,#+1
   \                     ??parse_string_0: (+1)
   \   00000028   0x7829             LDRB     R1,[R5, #+0]
   \   0000002A   0x2922             CMP      R1,#+34
   \   0000002C   0xD005             BEQ.N    ??parse_string_3
   \   0000002E   0x7829             LDRB     R1,[R5, #+0]
   \   00000030   0x2900             CMP      R1,#+0
   \   00000032   0xD002             BEQ.N    ??parse_string_3
   \   00000034   0x1C40             ADDS     R0,R0,#+1
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD1F0             BNE.N    ??parse_string_2
    256          
    257              out = (char *)cJSON_malloc(len + 1);	/* This is how long we need for the string, roughly. */
   \                     ??parse_string_3: (+1)
   \   0000003A   0x1C40             ADDS     R0,R0,#+1
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable14_1
   \   00000040   0x6809             LDR      R1,[R1, #+0]
   \   00000042   0x4788             BLX      R1
   \   00000044   0x0007             MOVS     R7,R0
    258              if (!out) return 0;
   \   00000046   0x2F00             CMP      R7,#+0
   \   00000048   0xD101             BNE.N    ??parse_string_4
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0xE0A9             B.N      ??parse_string_1
    259          
    260              ptr = str + 1;
   \                     ??parse_string_4: (+1)
   \   0000004E   0x1C75             ADDS     R5,R6,#+1
    261              ptr2 = out;
   \   00000050   0x003E             MOVS     R6,R7
   \   00000052   0xE003             B.N      ??parse_string_5
    262              while (*ptr != '\"' && *ptr)
    263              {
    264                  if (*ptr != '\\') *ptr2++ = *ptr++;
   \                     ??parse_string_6: (+1)
   \   00000054   0x7828             LDRB     R0,[R5, #+0]
   \   00000056   0x7030             STRB     R0,[R6, #+0]
   \   00000058   0x1C6D             ADDS     R5,R5,#+1
   \   0000005A   0x1C76             ADDS     R6,R6,#+1
   \                     ??parse_string_5: (+1)
   \   0000005C   0x7828             LDRB     R0,[R5, #+0]
   \   0000005E   0x2822             CMP      R0,#+34
   \   00000060   0xF000 0x8095      BEQ.W    ??parse_string_7
   \   00000064   0x7828             LDRB     R0,[R5, #+0]
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xF000 0x8091      BEQ.W    ??parse_string_7
   \   0000006C   0x7828             LDRB     R0,[R5, #+0]
   \   0000006E   0x285C             CMP      R0,#+92
   \   00000070   0xD1F0             BNE.N    ??parse_string_6
    265                  else
    266                  {
    267                      ptr++;
   \   00000072   0x1C6D             ADDS     R5,R5,#+1
    268                      switch (*ptr)
   \   00000074   0x7828             LDRB     R0,[R5, #+0]
   \   00000076   0x2862             CMP      R0,#+98
   \   00000078   0xD00A             BEQ.N    ??parse_string_8
   \   0000007A   0x2866             CMP      R0,#+102
   \   0000007C   0xD00C             BEQ.N    ??parse_string_9
   \   0000007E   0x286E             CMP      R0,#+110
   \   00000080   0xD00E             BEQ.N    ??parse_string_10
   \   00000082   0x2872             CMP      R0,#+114
   \   00000084   0xD010             BEQ.N    ??parse_string_11
   \   00000086   0x2874             CMP      R0,#+116
   \   00000088   0xD012             BEQ.N    ??parse_string_12
   \   0000008A   0x2875             CMP      R0,#+117
   \   0000008C   0xD014             BEQ.N    ??parse_string_13
   \   0000008E   0xE079             B.N      ??parse_string_14
    269                      {
    270                      case 'b':
    271                          *ptr2++ = '\b';
   \                     ??parse_string_8: (+1)
   \   00000090   0x2008             MOVS     R0,#+8
   \   00000092   0x7030             STRB     R0,[R6, #+0]
   \   00000094   0x1C76             ADDS     R6,R6,#+1
    272                          break;
   \   00000096   0xE078             B.N      ??parse_string_15
    273                      case 'f':
    274                          *ptr2++ = '\f';
   \                     ??parse_string_9: (+1)
   \   00000098   0x200C             MOVS     R0,#+12
   \   0000009A   0x7030             STRB     R0,[R6, #+0]
   \   0000009C   0x1C76             ADDS     R6,R6,#+1
    275                          break;
   \   0000009E   0xE074             B.N      ??parse_string_15
    276                      case 'n':
    277                          *ptr2++ = '\n';
   \                     ??parse_string_10: (+1)
   \   000000A0   0x200A             MOVS     R0,#+10
   \   000000A2   0x7030             STRB     R0,[R6, #+0]
   \   000000A4   0x1C76             ADDS     R6,R6,#+1
    278                          break;
   \   000000A6   0xE070             B.N      ??parse_string_15
    279                      case 'r':
    280                          *ptr2++ = '\r';
   \                     ??parse_string_11: (+1)
   \   000000A8   0x200D             MOVS     R0,#+13
   \   000000AA   0x7030             STRB     R0,[R6, #+0]
   \   000000AC   0x1C76             ADDS     R6,R6,#+1
    281                          break;
   \   000000AE   0xE06C             B.N      ??parse_string_15
    282                      case 't':
    283                          *ptr2++ = '\t';
   \                     ??parse_string_12: (+1)
   \   000000B0   0x2009             MOVS     R0,#+9
   \   000000B2   0x7030             STRB     R0,[R6, #+0]
   \   000000B4   0x1C76             ADDS     R6,R6,#+1
    284                          break;
   \   000000B6   0xE068             B.N      ??parse_string_15
    285                      case 'u':	 /* transcode utf16 to utf8. */
    286                          uc = parse_hex4(ptr + 1);
   \                     ??parse_string_13: (+1)
   \   000000B8   0x1C68             ADDS     R0,R5,#+1
   \   000000BA   0x.... 0x....      BL       parse_hex4
   \   000000BE   0x4680             MOV      R8,R0
    287                          ptr += 4;	/* get the unicode char. */
   \   000000C0   0x1D2D             ADDS     R5,R5,#+4
    288          
    289                          if ((uc >= 0xDC00 && uc <= 0xDFFF) || uc == 0)	break;	/* check for invalid.	*/
   \   000000C2   0xF5B8 0x405C      SUBS     R0,R8,#+56320
   \   000000C6   0xF5B0 0x6F80      CMP      R0,#+1024
   \   000000CA   0xD302             BCC.N    ??parse_string_16
   \   000000CC   0xF1B8 0x0F00      CMP      R8,#+0
   \   000000D0   0xD100             BNE.N    ??parse_string_17
   \                     ??parse_string_16: (+1)
   \   000000D2   0xE05A             B.N      ??parse_string_15
    290          
    291                          if (uc >= 0xD800 && uc <= 0xDBFF)	/* UTF16 surrogate pairs.	*/
   \                     ??parse_string_17: (+1)
   \   000000D4   0xF5B8 0x4058      SUBS     R0,R8,#+55296
   \   000000D8   0xF5B0 0x6F80      CMP      R0,#+1024
   \   000000DC   0xD219             BCS.N    ??parse_string_18
    292                          {
    293                              if (ptr[1] != '\\' || ptr[2] != 'u')	break;	/* missing second-half of surrogate.	*/
   \   000000DE   0x7868             LDRB     R0,[R5, #+1]
   \   000000E0   0x285C             CMP      R0,#+92
   \   000000E2   0xD102             BNE.N    ??parse_string_19
   \   000000E4   0x78A8             LDRB     R0,[R5, #+2]
   \   000000E6   0x2875             CMP      R0,#+117
   \   000000E8   0xD000             BEQ.N    ??parse_string_20
   \                     ??parse_string_19: (+1)
   \   000000EA   0xE04E             B.N      ??parse_string_15
    294                              uc2 = parse_hex4(ptr + 3);
   \                     ??parse_string_20: (+1)
   \   000000EC   0x1CE8             ADDS     R0,R5,#+3
   \   000000EE   0x.... 0x....      BL       parse_hex4
    295                              ptr += 6;
   \   000000F2   0xF205 0x0506      ADDW     R5,R5,#+6
    296                              if (uc2 < 0xDC00 || uc2 > 0xDFFF)		break;	/* invalid second-half of surrogate.	*/
   \   000000F6   0xF5B0 0x415C      SUBS     R1,R0,#+56320
   \   000000FA   0xF5B1 0x6F80      CMP      R1,#+1024
   \   000000FE   0xD244             BCS.N    ??parse_string_15
    297                              uc = 0x10000 + (((uc & 0x3FF) << 10) | (uc2 & 0x3FF));
   \                     ??parse_string_21: (+1)
   \   00000100   0xEA5F 0x5188      LSLS     R1,R8,#+22       ;; ZeroExtS R1,R8,#+22,#+22
   \   00000104   0x0D89             LSRS     R1,R1,#+22
   \   00000106   0x0580             LSLS     R0,R0,#+22       ;; ZeroExtS R0,R0,#+22,#+22
   \   00000108   0x0D80             LSRS     R0,R0,#+22
   \   0000010A   0xEA50 0x2081      ORRS     R0,R0,R1, LSL #+10
   \   0000010E   0xF510 0x3880      ADDS     R8,R0,#+65536
    298                          }
    299          
    300                          len = 4;
   \                     ??parse_string_18: (+1)
   \   00000112   0x2004             MOVS     R0,#+4
    301                          if (uc < 0x80) len = 1;
   \   00000114   0xF1B8 0x0F80      CMP      R8,#+128
   \   00000118   0xD201             BCS.N    ??parse_string_22
   \   0000011A   0x2001             MOVS     R0,#+1
   \   0000011C   0xE008             B.N      ??parse_string_23
    302                          else if (uc < 0x800) len = 2;
   \                     ??parse_string_22: (+1)
   \   0000011E   0xF5B8 0x6F00      CMP      R8,#+2048
   \   00000122   0xD201             BCS.N    ??parse_string_24
   \   00000124   0x2002             MOVS     R0,#+2
   \   00000126   0xE003             B.N      ??parse_string_23
    303                          else if (uc < 0x10000) len = 3;
   \                     ??parse_string_24: (+1)
   \   00000128   0xF5B8 0x3F80      CMP      R8,#+65536
   \   0000012C   0xD200             BCS.N    ??parse_string_23
   \   0000012E   0x2003             MOVS     R0,#+3
    304                          ptr2 += len;
   \                     ??parse_string_23: (+1)
   \   00000130   0x1986             ADDS     R6,R0,R6
    305          
    306                          switch (len)
   \   00000132   0x2801             CMP      R0,#+1
   \   00000134   0xD01D             BEQ.N    ??parse_string_25
   \   00000136   0xD323             BCC.N    ??parse_string_26
   \   00000138   0x2803             CMP      R0,#+3
   \   0000013A   0xD00A             BEQ.N    ??parse_string_27
   \   0000013C   0xD311             BCC.N    ??parse_string_28
   \   0000013E   0x2804             CMP      R0,#+4
   \   00000140   0xD11E             BNE.N    ??parse_string_26
    307                          {
    308                          case 4:
    309                              *--ptr2 = ((uc | 0x80) & 0xBF);
   \                     ??parse_string_29: (+1)
   \   00000142   0x1E76             SUBS     R6,R6,#+1
   \   00000144   0xF018 0x01BF      ANDS     R1,R8,#0xBF
   \   00000148   0xF051 0x0180      ORRS     R1,R1,#0x80
   \   0000014C   0x7031             STRB     R1,[R6, #+0]
    310                              uc >>= 6;
   \   0000014E   0xEA5F 0x1898      LSRS     R8,R8,#+6
    311                          case 3:
    312                              *--ptr2 = ((uc | 0x80) & 0xBF);
   \                     ??parse_string_27: (+1)
   \   00000152   0x1E76             SUBS     R6,R6,#+1
   \   00000154   0xF018 0x01BF      ANDS     R1,R8,#0xBF
   \   00000158   0xF051 0x0180      ORRS     R1,R1,#0x80
   \   0000015C   0x7031             STRB     R1,[R6, #+0]
    313                              uc >>= 6;
   \   0000015E   0xEA5F 0x1898      LSRS     R8,R8,#+6
    314                          case 2:
    315                              *--ptr2 = ((uc | 0x80) & 0xBF);
   \                     ??parse_string_28: (+1)
   \   00000162   0x1E76             SUBS     R6,R6,#+1
   \   00000164   0xF018 0x01BF      ANDS     R1,R8,#0xBF
   \   00000168   0xF051 0x0180      ORRS     R1,R1,#0x80
   \   0000016C   0x7031             STRB     R1,[R6, #+0]
    316                              uc >>= 6;
   \   0000016E   0xEA5F 0x1898      LSRS     R8,R8,#+6
    317                          case 1:
    318                              *--ptr2 = (uc | firstByteMark[len]);
   \                     ??parse_string_25: (+1)
   \   00000172   0x1E76             SUBS     R6,R6,#+1
   \   00000174   0x.... 0x....      LDR.W    R1,??DataTable16_10
   \   00000178   0x5C41             LDRB     R1,[R0, R1]
   \   0000017A   0xEA51 0x0108      ORRS     R1,R1,R8
   \   0000017E   0x7031             STRB     R1,[R6, #+0]
    319                          }
    320                          ptr2 += len;
   \                     ??parse_string_26: (+1)
   \   00000180   0x1986             ADDS     R6,R0,R6
    321                          break;
   \   00000182   0xE002             B.N      ??parse_string_15
    322                      default:
    323                          *ptr2++ = *ptr;
   \                     ??parse_string_14: (+1)
   \   00000184   0x7828             LDRB     R0,[R5, #+0]
   \   00000186   0x7030             STRB     R0,[R6, #+0]
   \   00000188   0x1C76             ADDS     R6,R6,#+1
    324                          break;
    325                      }
    326                      ptr++;
   \                     ??parse_string_15: (+1)
   \   0000018A   0x1C6D             ADDS     R5,R5,#+1
   \   0000018C   0xE766             B.N      ??parse_string_5
    327                  }
    328              }
    329              *ptr2 = 0;
   \                     ??parse_string_7: (+1)
   \   0000018E   0x2000             MOVS     R0,#+0
   \   00000190   0x7030             STRB     R0,[R6, #+0]
    330              if (*ptr == '\"') ptr++;
   \   00000192   0x7828             LDRB     R0,[R5, #+0]
   \   00000194   0x2822             CMP      R0,#+34
   \   00000196   0xD100             BNE.N    ??parse_string_30
   \   00000198   0x1C6D             ADDS     R5,R5,#+1
    331              item->valuestring = out;
   \                     ??parse_string_30: (+1)
   \   0000019A   0x6127             STR      R7,[R4, #+16]
    332              item->type = cJSON_String;
   \   0000019C   0x2004             MOVS     R0,#+4
   \   0000019E   0x60E0             STR      R0,[R4, #+12]
    333              return ptr;
   \   000001A0   0x0028             MOVS     R0,R5
   \                     ??parse_string_1: (+1)
   \   000001A2   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    334          }
    335          
    336          /* Render the cstring provided to an escaped version that can be printed. */

   \                                 In section .text, align 2, keep-with-next
    337          static char *print_string_ptr(const char *str, printbuffer *p)
    338          {
   \                     print_string_ptr: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x000F             MOVS     R7,R1
    339              const char *ptr;
    340              char *ptr2, *out;
    341              int len = 0, flag = 0;
   \   00000008   0x2600             MOVS     R6,#+0
   \   0000000A   0x2000             MOVS     R0,#+0
    342              unsigned char token;
    343          
    344              for (ptr = str; *ptr; ptr++) flag |= ((*ptr > 0 && *ptr < 32) || (*ptr == '\"') || (*ptr == '\\')) ? 1 : 0;
   \   0000000C   0x002C             MOVS     R4,R5
   \   0000000E   0xE002             B.N      ??print_string_ptr_0
   \                     ??print_string_ptr_1: (+1)
   \   00000010   0x2100             MOVS     R1,#+0
   \                     ??print_string_ptr_2: (+1)
   \   00000012   0x4308             ORRS     R0,R1,R0
   \   00000014   0x1C64             ADDS     R4,R4,#+1
   \                     ??print_string_ptr_0: (+1)
   \   00000016   0x7821             LDRB     R1,[R4, #+0]
   \   00000018   0x2900             CMP      R1,#+0
   \   0000001A   0xD00D             BEQ.N    ??print_string_ptr_3
   \   0000001C   0x7821             LDRB     R1,[R4, #+0]
   \   0000001E   0x2900             CMP      R1,#+0
   \   00000020   0xD002             BEQ.N    ??print_string_ptr_4
   \   00000022   0x7821             LDRB     R1,[R4, #+0]
   \   00000024   0x2920             CMP      R1,#+32
   \   00000026   0xDB05             BLT.N    ??print_string_ptr_5
   \                     ??print_string_ptr_4: (+1)
   \   00000028   0x7821             LDRB     R1,[R4, #+0]
   \   0000002A   0x2922             CMP      R1,#+34
   \   0000002C   0xD002             BEQ.N    ??print_string_ptr_5
   \   0000002E   0x7821             LDRB     R1,[R4, #+0]
   \   00000030   0x295C             CMP      R1,#+92
   \   00000032   0xD1ED             BNE.N    ??print_string_ptr_1
   \                     ??print_string_ptr_5: (+1)
   \   00000034   0x2101             MOVS     R1,#+1
   \   00000036   0xE7EC             B.N      ??print_string_ptr_2
    345              if (!flag)
   \                     ??print_string_ptr_3: (+1)
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD125             BNE.N    ??print_string_ptr_6
    346              {
    347                  len = ptr - str;
   \   0000003C   0x1B66             SUBS     R6,R4,R5
    348                  if (p) out = ensure(p, len + 3);
   \   0000003E   0x2F00             CMP      R7,#+0
   \   00000040   0xD005             BEQ.N    ??print_string_ptr_7
   \   00000042   0x1CF1             ADDS     R1,R6,#+3
   \   00000044   0x0038             MOVS     R0,R7
   \   00000046   0x.... 0x....      BL       ensure
   \   0000004A   0x0007             MOVS     R7,R0
   \   0000004C   0xE005             B.N      ??print_string_ptr_8
    349                  else		out = (char *)cJSON_malloc(len + 3);
   \                     ??print_string_ptr_7: (+1)
   \   0000004E   0x1CF0             ADDS     R0,R6,#+3
   \   00000050   0x.... 0x....      LDR.W    R1,??DataTable14_1
   \   00000054   0x6809             LDR      R1,[R1, #+0]
   \   00000056   0x4788             BLX      R1
   \   00000058   0x0007             MOVS     R7,R0
    350                  if (!out) return 0;
   \                     ??print_string_ptr_8: (+1)
   \   0000005A   0x2F00             CMP      R7,#+0
   \   0000005C   0xD101             BNE.N    ??print_string_ptr_9
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xE0CD             B.N      ??print_string_ptr_10
    351                  ptr2 = out;
   \                     ??print_string_ptr_9: (+1)
   \   00000062   0x46B8             MOV      R8,R7
    352                  *ptr2++ = '\"';
   \   00000064   0x2022             MOVS     R0,#+34
   \   00000066   0xF888 0x0000      STRB     R0,[R8, #+0]
   \   0000006A   0xF118 0x0801      ADDS     R8,R8,#+1
    353                  strcpy(ptr2, str);
   \   0000006E   0x0029             MOVS     R1,R5
   \   00000070   0x4640             MOV      R0,R8
   \   00000072   0x.... 0x....      BL       strcpy
    354                  ptr2[len] = '\"';
   \   00000076   0x2022             MOVS     R0,#+34
   \   00000078   0xF806 0x0008      STRB     R0,[R6, R8]
    355                  ptr2[len + 1] = 0;
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0xEB16 0x0108      ADDS     R1,R6,R8
   \   00000082   0x7048             STRB     R0,[R1, #+1]
    356                  return out;
   \   00000084   0x0038             MOVS     R0,R7
   \   00000086   0xE0BA             B.N      ??print_string_ptr_10
    357              }
    358          
    359              if (!str)
   \                     ??print_string_ptr_6: (+1)
   \   00000088   0x2D00             CMP      R5,#+0
   \   0000008A   0xD117             BNE.N    ??print_string_ptr_11
    360              {
    361                  if (p)	out = ensure(p, 3);
   \   0000008C   0x2F00             CMP      R7,#+0
   \   0000008E   0xD005             BEQ.N    ??print_string_ptr_12
   \   00000090   0x2103             MOVS     R1,#+3
   \   00000092   0x0038             MOVS     R0,R7
   \   00000094   0x.... 0x....      BL       ensure
   \   00000098   0x0007             MOVS     R7,R0
   \   0000009A   0xE005             B.N      ??print_string_ptr_13
    362                  else	out = (char *)cJSON_malloc(3);
   \                     ??print_string_ptr_12: (+1)
   \   0000009C   0x2003             MOVS     R0,#+3
   \   0000009E   0x.... 0x....      LDR.W    R1,??DataTable14_1
   \   000000A2   0x6809             LDR      R1,[R1, #+0]
   \   000000A4   0x4788             BLX      R1
   \   000000A6   0x0007             MOVS     R7,R0
    363                  if (!out) return 0;
   \                     ??print_string_ptr_13: (+1)
   \   000000A8   0x2F00             CMP      R7,#+0
   \   000000AA   0xD101             BNE.N    ??print_string_ptr_14
   \   000000AC   0x2000             MOVS     R0,#+0
   \   000000AE   0xE0A6             B.N      ??print_string_ptr_10
    364                  strcpy(out, "\"\"");
   \                     ??print_string_ptr_14: (+1)
   \   000000B0   0x....             ADR.N    R1,??DataTable12  ;; 0x22, 0x22, 0x00, 0x00
   \   000000B2   0x0038             MOVS     R0,R7
   \   000000B4   0x.... 0x....      BL       strcpy
    365                  return out;
   \   000000B8   0x0038             MOVS     R0,R7
   \   000000BA   0xE0A0             B.N      ??print_string_ptr_10
    366              }
    367              ptr = str;
   \                     ??print_string_ptr_11: (+1)
   \   000000BC   0x002C             MOVS     R4,R5
   \   000000BE   0xE006             B.N      ??print_string_ptr_15
    368              while ((token = *ptr) && ++len)
    369              {
    370                  if (strchr("\"\\\b\f\n\r\t", token)) len++;
    371                  else if (token < 32) len += 5;
   \                     ??print_string_ptr_16: (+1)
   \   000000C0   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000000C4   0xF1B9 0x0F20      CMP      R9,#+32
   \   000000C8   0xDA00             BGE.N    ??print_string_ptr_17
   \   000000CA   0x1D76             ADDS     R6,R6,#+5
    372                  ptr++;
   \                     ??print_string_ptr_17: (+1)
   \   000000CC   0x1C64             ADDS     R4,R4,#+1
   \                     ??print_string_ptr_15: (+1)
   \   000000CE   0xF894 0x9000      LDRB     R9,[R4, #+0]
   \   000000D2   0x4648             MOV      R0,R9
   \   000000D4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000D6   0x2800             CMP      R0,#+0
   \   000000D8   0xD00D             BEQ.N    ??print_string_ptr_18
   \   000000DA   0x1C76             ADDS     R6,R6,#+1
   \   000000DC   0x2E00             CMP      R6,#+0
   \   000000DE   0xD00A             BEQ.N    ??print_string_ptr_18
   \   000000E0   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000000E4   0x4649             MOV      R1,R9
   \   000000E6   0x.... 0x....      LDR.W    R0,??DataTable17
   \   000000EA   0x.... 0x....      BL       strchr
   \   000000EE   0x2800             CMP      R0,#+0
   \   000000F0   0xD0E6             BEQ.N    ??print_string_ptr_16
   \   000000F2   0x1C76             ADDS     R6,R6,#+1
   \   000000F4   0xE7EA             B.N      ??print_string_ptr_17
    373              }
    374          
    375              if (p)	out = ensure(p, len + 3);
   \                     ??print_string_ptr_18: (+1)
   \   000000F6   0x2F00             CMP      R7,#+0
   \   000000F8   0xD005             BEQ.N    ??print_string_ptr_19
   \   000000FA   0x1CF1             ADDS     R1,R6,#+3
   \   000000FC   0x0038             MOVS     R0,R7
   \   000000FE   0x.... 0x....      BL       ensure
   \   00000102   0x0007             MOVS     R7,R0
   \   00000104   0xE005             B.N      ??print_string_ptr_20
    376              else	out = (char *)cJSON_malloc(len + 3);
   \                     ??print_string_ptr_19: (+1)
   \   00000106   0x1CF0             ADDS     R0,R6,#+3
   \   00000108   0x.... 0x....      LDR.W    R1,??DataTable14_1
   \   0000010C   0x6809             LDR      R1,[R1, #+0]
   \   0000010E   0x4788             BLX      R1
   \   00000110   0x0007             MOVS     R7,R0
    377              if (!out) return 0;
   \                     ??print_string_ptr_20: (+1)
   \   00000112   0x2F00             CMP      R7,#+0
   \   00000114   0xD101             BNE.N    ??print_string_ptr_21
   \   00000116   0x2000             MOVS     R0,#+0
   \   00000118   0xE071             B.N      ??print_string_ptr_10
    378          
    379              ptr2 = out;
   \                     ??print_string_ptr_21: (+1)
   \   0000011A   0x46B8             MOV      R8,R7
    380              ptr = str;
   \   0000011C   0x002C             MOVS     R4,R5
    381              *ptr2++ = '\"';
   \   0000011E   0x2022             MOVS     R0,#+34
   \   00000120   0xF888 0x0000      STRB     R0,[R8, #+0]
   \   00000124   0xF118 0x0801      ADDS     R8,R8,#+1
   \   00000128   0xE005             B.N      ??print_string_ptr_22
    382              while (*ptr)
    383              {
    384                  if ((unsigned char)*ptr > 31 && *ptr != '\"' && *ptr != '\\') *ptr2++ = *ptr++;
   \                     ??print_string_ptr_23: (+1)
   \   0000012A   0x7820             LDRB     R0,[R4, #+0]
   \   0000012C   0xF888 0x0000      STRB     R0,[R8, #+0]
   \   00000130   0x1C64             ADDS     R4,R4,#+1
   \   00000132   0xF118 0x0801      ADDS     R8,R8,#+1
   \                     ??print_string_ptr_22: (+1)
   \   00000136   0x7820             LDRB     R0,[R4, #+0]
   \   00000138   0x2800             CMP      R0,#+0
   \   0000013A   0xD055             BEQ.N    ??print_string_ptr_24
   \   0000013C   0x7820             LDRB     R0,[R4, #+0]
   \   0000013E   0x2820             CMP      R0,#+32
   \   00000140   0xDB05             BLT.N    ??print_string_ptr_25
   \   00000142   0x7820             LDRB     R0,[R4, #+0]
   \   00000144   0x2822             CMP      R0,#+34
   \   00000146   0xD002             BEQ.N    ??print_string_ptr_25
   \   00000148   0x7820             LDRB     R0,[R4, #+0]
   \   0000014A   0x285C             CMP      R0,#+92
   \   0000014C   0xD1ED             BNE.N    ??print_string_ptr_23
    385                  else
    386                  {
    387                      *ptr2++ = '\\';
   \                     ??print_string_ptr_25: (+1)
   \   0000014E   0x205C             MOVS     R0,#+92
   \   00000150   0xF888 0x0000      STRB     R0,[R8, #+0]
   \   00000154   0xF118 0x0801      ADDS     R8,R8,#+1
    388                      switch (token = *ptr++)
   \   00000158   0xF894 0x9000      LDRB     R9,[R4, #+0]
   \   0000015C   0x1C64             ADDS     R4,R4,#+1
   \   0000015E   0x4648             MOV      R0,R9
   \   00000160   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000162   0x2808             CMP      R0,#+8
   \   00000164   0xD017             BEQ.N    ??print_string_ptr_26
   \   00000166   0x2809             CMP      R0,#+9
   \   00000168   0xD02D             BEQ.N    ??print_string_ptr_27
   \   0000016A   0x280A             CMP      R0,#+10
   \   0000016C   0xD01F             BEQ.N    ??print_string_ptr_28
   \   0000016E   0x280C             CMP      R0,#+12
   \   00000170   0xD017             BEQ.N    ??print_string_ptr_29
   \   00000172   0x280D             CMP      R0,#+13
   \   00000174   0xD021             BEQ.N    ??print_string_ptr_30
   \   00000176   0x2822             CMP      R0,#+34
   \   00000178   0xD007             BEQ.N    ??print_string_ptr_31
   \   0000017A   0x285C             CMP      R0,#+92
   \   0000017C   0xD129             BNE.N    ??print_string_ptr_32
    389                      {
    390                      case '\\':
    391                          *ptr2++ = '\\';
   \                     ??print_string_ptr_33: (+1)
   \   0000017E   0x205C             MOVS     R0,#+92
   \   00000180   0xF888 0x0000      STRB     R0,[R8, #+0]
   \   00000184   0xF118 0x0801      ADDS     R8,R8,#+1
    392                          break;
   \   00000188   0xE7D5             B.N      ??print_string_ptr_22
    393                      case '\"':
    394                          *ptr2++ = '\"';
   \                     ??print_string_ptr_31: (+1)
   \   0000018A   0x2022             MOVS     R0,#+34
   \   0000018C   0xF888 0x0000      STRB     R0,[R8, #+0]
   \   00000190   0xF118 0x0801      ADDS     R8,R8,#+1
    395                          break;
   \   00000194   0xE7CF             B.N      ??print_string_ptr_22
    396                      case '\b':
    397                          *ptr2++ = 'b';
   \                     ??print_string_ptr_26: (+1)
   \   00000196   0x2062             MOVS     R0,#+98
   \   00000198   0xF888 0x0000      STRB     R0,[R8, #+0]
   \   0000019C   0xF118 0x0801      ADDS     R8,R8,#+1
    398                          break;
   \   000001A0   0xE7C9             B.N      ??print_string_ptr_22
    399                      case '\f':
    400                          *ptr2++ = 'f';
   \                     ??print_string_ptr_29: (+1)
   \   000001A2   0x2066             MOVS     R0,#+102
   \   000001A4   0xF888 0x0000      STRB     R0,[R8, #+0]
   \   000001A8   0xF118 0x0801      ADDS     R8,R8,#+1
    401                          break;
   \   000001AC   0xE7C3             B.N      ??print_string_ptr_22
    402                      case '\n':
    403                          *ptr2++ = 'n';
   \                     ??print_string_ptr_28: (+1)
   \   000001AE   0x206E             MOVS     R0,#+110
   \   000001B0   0xF888 0x0000      STRB     R0,[R8, #+0]
   \   000001B4   0xF118 0x0801      ADDS     R8,R8,#+1
    404                          break;
   \   000001B8   0xE7BD             B.N      ??print_string_ptr_22
    405                      case '\r':
    406                          *ptr2++ = 'r';
   \                     ??print_string_ptr_30: (+1)
   \   000001BA   0x2072             MOVS     R0,#+114
   \   000001BC   0xF888 0x0000      STRB     R0,[R8, #+0]
   \   000001C0   0xF118 0x0801      ADDS     R8,R8,#+1
    407                          break;
   \   000001C4   0xE7B7             B.N      ??print_string_ptr_22
    408                      case '\t':
    409                          *ptr2++ = 't';
   \                     ??print_string_ptr_27: (+1)
   \   000001C6   0x2074             MOVS     R0,#+116
   \   000001C8   0xF888 0x0000      STRB     R0,[R8, #+0]
   \   000001CC   0xF118 0x0801      ADDS     R8,R8,#+1
    410                          break;
   \   000001D0   0xE7B1             B.N      ??print_string_ptr_22
    411                      default:
    412                          sprintf(ptr2, "u%04x", token);
   \                     ??print_string_ptr_32: (+1)
   \   000001D2   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000001D6   0x464A             MOV      R2,R9
   \   000001D8   0x.... 0x....      LDR.W    R1,??DataTable19
   \   000001DC   0x4640             MOV      R0,R8
   \   000001DE   0x.... 0x....      BL       sprintf
    413                          ptr2 += 5;
   \   000001E2   0xF208 0x0805      ADDW     R8,R8,#+5
    414                          break;	/* escape and print */
   \   000001E6   0xE7A6             B.N      ??print_string_ptr_22
    415                      }
    416                  }
    417              }
    418              *ptr2++ = '\"';
   \                     ??print_string_ptr_24: (+1)
   \   000001E8   0x2022             MOVS     R0,#+34
   \   000001EA   0xF888 0x0000      STRB     R0,[R8, #+0]
   \   000001EE   0xF118 0x0801      ADDS     R8,R8,#+1
    419              *ptr2++ = 0;
   \   000001F2   0x2000             MOVS     R0,#+0
   \   000001F4   0xF888 0x0000      STRB     R0,[R8, #+0]
   \   000001F8   0xF118 0x0801      ADDS     R8,R8,#+1
    420              return out;
   \   000001FC   0x0038             MOVS     R0,R7
   \                     ??print_string_ptr_10: (+1)
   \   000001FE   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    421          }
    422          /* Invote print_string_ptr (which is useful) on an item. */

   \                                 In section .text, align 2, keep-with-next
    423          static char *print_string(cJSON *item, printbuffer *p)
    424          {
   \                     print_string: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    425              return print_string_ptr(item->valuestring, p);
   \   00000002   0x6900             LDR      R0,[R0, #+16]
   \   00000004   0x.... 0x....      BL       print_string_ptr
   \   00000008   0xBD02             POP      {R1,PC}          ;; return
    426          }
    427          
    428          /* Predeclare these prototypes. */
    429          static const char *parse_value(cJSON *item, const char *value);
    430          static char *print_value(cJSON *item, int depth, int fmt, printbuffer *p);
    431          static const char *parse_array(cJSON *item, const char *value);
    432          static char *print_array(cJSON *item, int depth, int fmt, printbuffer *p);
    433          static const char *parse_object(cJSON *item, const char *value);
    434          static char *print_object(cJSON *item, int depth, int fmt, printbuffer *p);
    435          
    436          /* Utility to jump whitespace and cr/lf */

   \                                 In section .text, align 2, keep-with-next
    437          static const char *skip(const char *in)
    438          {
   \                     skip: (+1)
   \   00000000   0xE000             B.N      ??skip_0
    439              while (in && *in && (unsigned char)*in <= 32) in++;
   \                     ??skip_1: (+1)
   \   00000002   0x1C40             ADDS     R0,R0,#+1
   \                     ??skip_0: (+1)
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD005             BEQ.N    ??skip_2
   \   00000008   0x7801             LDRB     R1,[R0, #+0]
   \   0000000A   0x2900             CMP      R1,#+0
   \   0000000C   0xD002             BEQ.N    ??skip_2
   \   0000000E   0x7801             LDRB     R1,[R0, #+0]
   \   00000010   0x2921             CMP      R1,#+33
   \   00000012   0xDBF6             BLT.N    ??skip_1
    440              return in;
   \                     ??skip_2: (+1)
   \   00000014   0x4770             BX       LR               ;; return
    441          }
    442          
    443          /* Parse an object - create a new root, and populate. */

   \                                 In section .text, align 2, keep-with-next
    444          cJSON *cJSON_ParseWithOpts(const char *value, const char **return_parse_end, int require_null_terminated)
    445          {
   \                     cJSON_ParseWithOpts: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x000E             MOVS     R6,R1
   \   00000008   0x0017             MOVS     R7,R2
    446              const char *end = 0;
   \   0000000A   0x2400             MOVS     R4,#+0
    447              cJSON *c = cJSON_New_Item();
   \   0000000C   0x.... 0x....      BL       cJSON_New_Item
   \   00000010   0x4680             MOV      R8,R0
    448              ep = 0;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x....             LDR.N    R1,??DataTable14
   \   00000016   0x6008             STR      R0,[R1, #+0]
    449              if (!c) return 0;       /* memory fail */
   \   00000018   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000001C   0xD101             BNE.N    ??cJSON_ParseWithOpts_0
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xE022             B.N      ??cJSON_ParseWithOpts_1
    450          
    451              end = parse_value(c, skip(value));
   \                     ??cJSON_ParseWithOpts_0: (+1)
   \   00000022   0x0028             MOVS     R0,R5
   \   00000024   0x.... 0x....      BL       skip
   \   00000028   0x0001             MOVS     R1,R0
   \   0000002A   0x4640             MOV      R0,R8
   \   0000002C   0x.... 0x....      BL       parse_value
   \   00000030   0x0004             MOVS     R4,R0
    452              if (!end)
   \   00000032   0x2C00             CMP      R4,#+0
   \   00000034   0xD104             BNE.N    ??cJSON_ParseWithOpts_2
    453              {
    454                  cJSON_Delete(c);    /* parse failure. ep is set. */
   \   00000036   0x4640             MOV      R0,R8
   \   00000038   0x.... 0x....      BL       cJSON_Delete
    455                  return 0;
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0xE013             B.N      ??cJSON_ParseWithOpts_1
    456              }
    457          
    458              /* if we require null-terminated JSON without appended garbage, skip and then check for a null terminator */
    459              if (require_null_terminated)
   \                     ??cJSON_ParseWithOpts_2: (+1)
   \   00000040   0x2F00             CMP      R7,#+0
   \   00000042   0xD00D             BEQ.N    ??cJSON_ParseWithOpts_3
    460              {
    461                  end = skip(end);
   \   00000044   0x0020             MOVS     R0,R4
   \   00000046   0x.... 0x....      BL       skip
   \   0000004A   0x0004             MOVS     R4,R0
    462                  if (*end)
   \   0000004C   0x7820             LDRB     R0,[R4, #+0]
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD006             BEQ.N    ??cJSON_ParseWithOpts_3
    463                  {
    464                      cJSON_Delete(c);
   \   00000052   0x4640             MOV      R0,R8
   \   00000054   0x.... 0x....      BL       cJSON_Delete
    465                      ep = end;
   \   00000058   0x....             LDR.N    R0,??DataTable14
   \   0000005A   0x6004             STR      R4,[R0, #+0]
    466                      return 0;
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0xE003             B.N      ??cJSON_ParseWithOpts_1
    467                  }
    468              }
    469              if (return_parse_end) *return_parse_end = end;
   \                     ??cJSON_ParseWithOpts_3: (+1)
   \   00000060   0x2E00             CMP      R6,#+0
   \   00000062   0xD000             BEQ.N    ??cJSON_ParseWithOpts_4
   \   00000064   0x6034             STR      R4,[R6, #+0]
    470              return c;
   \                     ??cJSON_ParseWithOpts_4: (+1)
   \   00000066   0x4640             MOV      R0,R8
   \                     ??cJSON_ParseWithOpts_1: (+1)
   \   00000068   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    471          }
    472          /* Default options for cJSON_Parse */

   \                                 In section .text, align 2, keep-with-next
    473          cJSON *cJSON_Parse(const char *value)
    474          {
   \                     cJSON_Parse: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    475              return cJSON_ParseWithOpts(value, 0, 0);
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x.... 0x....      BL       cJSON_ParseWithOpts
   \   0000000A   0xBD02             POP      {R1,PC}          ;; return
    476          }
    477          
    478          /* Render a cJSON item/entity/structure to text. */

   \                                 In section .text, align 2, keep-with-next
    479          char *cJSON_Print(cJSON *item)
    480          {
   \                     cJSON_Print: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    481              return print_value(item, 0, 1, 0);
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x.... 0x....      BL       print_value
   \   0000000C   0xBD02             POP      {R1,PC}          ;; return
    482          }

   \                                 In section .text, align 2, keep-with-next
    483          char *cJSON_PrintUnformatted(cJSON *item)
    484          {
   \                     cJSON_PrintUnformatted: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    485              return print_value(item, 0, 0, 0);
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x.... 0x....      BL       print_value
   \   0000000C   0xBD02             POP      {R1,PC}          ;; return
    486          }
    487          

   \                                 In section .text, align 2, keep-with-next
    488          char *cJSON_PrintBuffered(cJSON *item, int prebuffer, int fmt)
    489          {
   \                     cJSON_PrintBuffered: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000E             MOVS     R6,R1
   \   00000008   0x0015             MOVS     R5,R2
    490              printbuffer p;
    491              p.buffer = (char *)cJSON_malloc(prebuffer);
   \   0000000A   0x0030             MOVS     R0,R6
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable19_1
   \   00000010   0x6809             LDR      R1,[R1, #+0]
   \   00000012   0x4788             BLX      R1
   \   00000014   0x9000             STR      R0,[SP, #+0]
    492              p.length = prebuffer;
   \   00000016   0x9601             STR      R6,[SP, #+4]
    493              p.offset = 0;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x9002             STR      R0,[SP, #+8]
    494              return print_value(item, 0, fmt, &p);
   \   0000001C   0xAB00             ADD      R3,SP,#+0
   \   0000001E   0x002A             MOVS     R2,R5
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x0020             MOVS     R0,R4
   \   00000024   0x.... 0x....      BL       print_value
   \   00000028   0xB004             ADD      SP,SP,#+16
   \   0000002A   0xBD70             POP      {R4-R6,PC}       ;; return
    495              return p.buffer;
    496          }
    497          
    498          
    499          /* Parser core - when encountering text, process appropriately. */

   \                                 In section .text, align 2, keep-with-next
    500          static const char *parse_value(cJSON *item, const char *value)
    501          {
   \                     parse_value: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    502              if (!value)						return 0;	/* Fail on null. */
   \   00000006   0x2D00             CMP      R5,#+0
   \   00000008   0xD101             BNE.N    ??parse_value_0
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xE04C             B.N      ??parse_value_1
    503              if (!strncmp(value, "null", 4))
   \                     ??parse_value_0: (+1)
   \   0000000E   0x2204             MOVS     R2,#+4
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable19_2
   \   00000014   0x0028             MOVS     R0,R5
   \   00000016   0x.... 0x....      BL       strncmp
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD103             BNE.N    ??parse_value_2
    504              {
    505                  item->type = cJSON_NULL;
   \   0000001E   0x2002             MOVS     R0,#+2
   \   00000020   0x60E0             STR      R0,[R4, #+12]
    506                  return value + 4;
   \   00000022   0x1D28             ADDS     R0,R5,#+4
   \   00000024   0xE040             B.N      ??parse_value_1
    507              }
    508              if (!strncmp(value, "false", 5))
   \                     ??parse_value_2: (+1)
   \   00000026   0x2205             MOVS     R2,#+5
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable19_3
   \   0000002C   0x0028             MOVS     R0,R5
   \   0000002E   0x.... 0x....      BL       strncmp
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD103             BNE.N    ??parse_value_3
    509              {
    510                  item->type = cJSON_False;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x60E0             STR      R0,[R4, #+12]
    511                  return value + 5;
   \   0000003A   0x1D68             ADDS     R0,R5,#+5
   \   0000003C   0xE034             B.N      ??parse_value_1
    512              }
    513              if (!strncmp(value, "true", 4))
   \                     ??parse_value_3: (+1)
   \   0000003E   0x2204             MOVS     R2,#+4
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable19_4
   \   00000044   0x0028             MOVS     R0,R5
   \   00000046   0x.... 0x....      BL       strncmp
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD105             BNE.N    ??parse_value_4
    514              {
    515                  item->type = cJSON_True;
   \   0000004E   0x2001             MOVS     R0,#+1
   \   00000050   0x60E0             STR      R0,[R4, #+12]
    516                  item->valueint = 1;
   \   00000052   0x2001             MOVS     R0,#+1
   \   00000054   0x6160             STR      R0,[R4, #+20]
    517                  return value + 4;
   \   00000056   0x1D28             ADDS     R0,R5,#+4
   \   00000058   0xE026             B.N      ??parse_value_1
    518              }
    519              if (*value == '\"')
   \                     ??parse_value_4: (+1)
   \   0000005A   0x7828             LDRB     R0,[R5, #+0]
   \   0000005C   0x2822             CMP      R0,#+34
   \   0000005E   0xD104             BNE.N    ??parse_value_5
    520              {
    521                  return parse_string(item, value);
   \   00000060   0x0029             MOVS     R1,R5
   \   00000062   0x0020             MOVS     R0,R4
   \   00000064   0x.... 0x....      BL       parse_string
   \   00000068   0xE01E             B.N      ??parse_value_1
    522              }
    523              if (*value == '-' || (*value >= '0' && *value <= '9'))
   \                     ??parse_value_5: (+1)
   \   0000006A   0x7828             LDRB     R0,[R5, #+0]
   \   0000006C   0x282D             CMP      R0,#+45
   \   0000006E   0xD003             BEQ.N    ??parse_value_6
   \   00000070   0x7828             LDRB     R0,[R5, #+0]
   \   00000072   0x3830             SUBS     R0,R0,#+48
   \   00000074   0x280A             CMP      R0,#+10
   \   00000076   0xD204             BCS.N    ??parse_value_7
    524              {
    525                  return parse_number(item, value);
   \                     ??parse_value_6: (+1)
   \   00000078   0x0029             MOVS     R1,R5
   \   0000007A   0x0020             MOVS     R0,R4
   \   0000007C   0x.... 0x....      BL       parse_number
   \   00000080   0xE012             B.N      ??parse_value_1
    526              }
    527              if (*value == '[')
   \                     ??parse_value_7: (+1)
   \   00000082   0x7828             LDRB     R0,[R5, #+0]
   \   00000084   0x285B             CMP      R0,#+91
   \   00000086   0xD104             BNE.N    ??parse_value_8
    528              {
    529                  return parse_array(item, value);
   \   00000088   0x0029             MOVS     R1,R5
   \   0000008A   0x0020             MOVS     R0,R4
   \   0000008C   0x.... 0x....      BL       parse_array
   \   00000090   0xE00A             B.N      ??parse_value_1
    530              }
    531              if (*value == '{')
   \                     ??parse_value_8: (+1)
   \   00000092   0x7828             LDRB     R0,[R5, #+0]
   \   00000094   0x287B             CMP      R0,#+123
   \   00000096   0xD104             BNE.N    ??parse_value_9
    532              {
    533                  return parse_object(item, value);
   \   00000098   0x0029             MOVS     R1,R5
   \   0000009A   0x0020             MOVS     R0,R4
   \   0000009C   0x.... 0x....      BL       parse_object
   \   000000A0   0xE002             B.N      ??parse_value_1
    534              }
    535          
    536              ep = value;
   \                     ??parse_value_9: (+1)
   \   000000A2   0x....             LDR.N    R0,??DataTable14
   \   000000A4   0x6005             STR      R5,[R0, #+0]
    537              return 0;	/* failure. */
   \   000000A6   0x2000             MOVS     R0,#+0
   \                     ??parse_value_1: (+1)
   \   000000A8   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    538          }
    539          
    540          /* Render a value to text. */

   \                                 In section .text, align 2, keep-with-next
    541          static char *print_value(cJSON *item, int depth, int fmt, printbuffer *p)
    542          {
   \                     print_value: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    543              char *out = 0;
   \   00000002   0x2400             MOVS     R4,#+0
    544              if (!item) return 0;
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD101             BNE.N    ??print_value_0
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xE07E             B.N      ??print_value_1
    545              if (p)
   \                     ??print_value_0: (+1)
   \   0000000C   0x2B00             CMP      R3,#+0
   \   0000000E   0xD047             BEQ.N    ??print_value_2
    546              {
    547                  switch ((item->type) & 255)
   \   00000010   0x7B05             LDRB     R5,[R0, #+12]
   \   00000012   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000014   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000016   0x2D00             CMP      R5,#+0
   \   00000018   0xD016             BEQ.N    ??print_value_3
   \   0000001A   0x2D02             CMP      R5,#+2
   \   0000001C   0xD007             BEQ.N    ??print_value_4
   \   0000001E   0xD320             BCC.N    ??print_value_5
   \   00000020   0x2D04             CMP      R5,#+4
   \   00000022   0xD030             BEQ.N    ??print_value_6
   \   00000024   0xD32A             BCC.N    ??print_value_7
   \   00000026   0x2D06             CMP      R5,#+6
   \   00000028   0xD036             BEQ.N    ??print_value_8
   \   0000002A   0xD331             BCC.N    ??print_value_9
   \   0000002C   0xE06C             B.N      ??print_value_10
    548                  {
    549                  case cJSON_NULL:
    550                  {
    551                      out = ensure(p, 5);
   \                     ??print_value_4: (+1)
   \   0000002E   0x2105             MOVS     R1,#+5
   \   00000030   0x0018             MOVS     R0,R3
   \   00000032   0x.... 0x....      BL       ensure
   \   00000036   0x0004             MOVS     R4,R0
    552                      if (out) strcpy(out, "null");
   \   00000038   0x2C00             CMP      R4,#+0
   \   0000003A   0xD004             BEQ.N    ??print_value_11
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable19_2
   \   00000040   0x0020             MOVS     R0,R4
   \   00000042   0x.... 0x....      BL       strcpy
    553                      break;
   \                     ??print_value_11: (+1)
   \   00000046   0xE05F             B.N      ??print_value_10
    554                  }
    555                  case cJSON_False:
    556                  {
    557                      out = ensure(p, 6);
   \                     ??print_value_3: (+1)
   \   00000048   0x2106             MOVS     R1,#+6
   \   0000004A   0x0018             MOVS     R0,R3
   \   0000004C   0x.... 0x....      BL       ensure
   \   00000050   0x0004             MOVS     R4,R0
    558                      if (out) strcpy(out, "false");
   \   00000052   0x2C00             CMP      R4,#+0
   \   00000054   0xD004             BEQ.N    ??print_value_12
   \   00000056   0x.... 0x....      LDR.W    R1,??DataTable19_3
   \   0000005A   0x0020             MOVS     R0,R4
   \   0000005C   0x.... 0x....      BL       strcpy
    559                      break;
   \                     ??print_value_12: (+1)
   \   00000060   0xE052             B.N      ??print_value_10
    560                  }
    561                  case cJSON_True:
    562                  {
    563                      out = ensure(p, 5);
   \                     ??print_value_5: (+1)
   \   00000062   0x2105             MOVS     R1,#+5
   \   00000064   0x0018             MOVS     R0,R3
   \   00000066   0x.... 0x....      BL       ensure
   \   0000006A   0x0004             MOVS     R4,R0
    564                      if (out) strcpy(out, "true");
   \   0000006C   0x2C00             CMP      R4,#+0
   \   0000006E   0xD004             BEQ.N    ??print_value_13
   \   00000070   0x.... 0x....      LDR.W    R1,??DataTable19_4
   \   00000074   0x0020             MOVS     R0,R4
   \   00000076   0x.... 0x....      BL       strcpy
    565                      break;
   \                     ??print_value_13: (+1)
   \   0000007A   0xE045             B.N      ??print_value_10
    566                  }
    567                  case cJSON_Number:
    568                      out = print_number(item, p);
   \                     ??print_value_7: (+1)
   \   0000007C   0x0019             MOVS     R1,R3
   \   0000007E   0x.... 0x....      BL       print_number
   \   00000082   0x0004             MOVS     R4,R0
    569                      break;
   \   00000084   0xE040             B.N      ??print_value_10
    570                  case cJSON_String:
    571                      out = print_string(item, p);
   \                     ??print_value_6: (+1)
   \   00000086   0x0019             MOVS     R1,R3
   \   00000088   0x.... 0x....      BL       print_string
   \   0000008C   0x0004             MOVS     R4,R0
    572                      break;
   \   0000008E   0xE03B             B.N      ??print_value_10
    573                  case cJSON_Array:
    574                      out = print_array(item, depth, fmt, p);
   \                     ??print_value_9: (+1)
   \   00000090   0x.... 0x....      BL       print_array
   \   00000094   0x0004             MOVS     R4,R0
    575                      break;
   \   00000096   0xE037             B.N      ??print_value_10
    576                  case cJSON_Object:
    577                      out = print_object(item, depth, fmt, p);
   \                     ??print_value_8: (+1)
   \   00000098   0x.... 0x....      BL       print_object
   \   0000009C   0x0004             MOVS     R4,R0
    578                      break;
   \   0000009E   0xE033             B.N      ??print_value_10
    579                  }
    580              }
    581              else
    582              {
    583                  switch ((item->type) & 255)
   \                     ??print_value_2: (+1)
   \   000000A0   0x7B03             LDRB     R3,[R0, #+12]
   \   000000A2   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000000A4   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000000A6   0x2B00             CMP      R3,#+0
   \   000000A8   0xD00F             BEQ.N    ??print_value_14
   \   000000AA   0x2B02             CMP      R3,#+2
   \   000000AC   0xD007             BEQ.N    ??print_value_15
   \   000000AE   0xD312             BCC.N    ??print_value_16
   \   000000B0   0x2B04             CMP      R3,#+4
   \   000000B2   0xD01B             BEQ.N    ??print_value_17
   \   000000B4   0xD315             BCC.N    ??print_value_18
   \   000000B6   0x2B06             CMP      R3,#+6
   \   000000B8   0xD022             BEQ.N    ??print_value_19
   \   000000BA   0xD31C             BCC.N    ??print_value_20
   \   000000BC   0xE024             B.N      ??print_value_10
    584                  {
    585                  case cJSON_NULL:
    586                      out = cJSON_strdup("null");
   \                     ??print_value_15: (+1)
   \   000000BE   0x.... 0x....      LDR.W    R0,??DataTable19_2
   \   000000C2   0x.... 0x....      BL       cJSON_strdup
   \   000000C6   0x0004             MOVS     R4,R0
    587                      break;
   \   000000C8   0xE01E             B.N      ??print_value_10
    588                  case cJSON_False:
    589                      out = cJSON_strdup("false");
   \                     ??print_value_14: (+1)
   \   000000CA   0x.... 0x....      LDR.W    R0,??DataTable19_3
   \   000000CE   0x.... 0x....      BL       cJSON_strdup
   \   000000D2   0x0004             MOVS     R4,R0
    590                      break;
   \   000000D4   0xE018             B.N      ??print_value_10
    591                  case cJSON_True:
    592                      out = cJSON_strdup("true");
   \                     ??print_value_16: (+1)
   \   000000D6   0x.... 0x....      LDR.W    R0,??DataTable19_4
   \   000000DA   0x.... 0x....      BL       cJSON_strdup
   \   000000DE   0x0004             MOVS     R4,R0
    593                      break;
   \   000000E0   0xE012             B.N      ??print_value_10
    594                  case cJSON_Number:
    595                      out = print_number(item, 0);
   \                     ??print_value_18: (+1)
   \   000000E2   0x2100             MOVS     R1,#+0
   \   000000E4   0x.... 0x....      BL       print_number
   \   000000E8   0x0004             MOVS     R4,R0
    596                      break;
   \   000000EA   0xE00D             B.N      ??print_value_10
    597                  case cJSON_String:
    598                      out = print_string(item, 0);
   \                     ??print_value_17: (+1)
   \   000000EC   0x2100             MOVS     R1,#+0
   \   000000EE   0x.... 0x....      BL       print_string
   \   000000F2   0x0004             MOVS     R4,R0
    599                      break;
   \   000000F4   0xE008             B.N      ??print_value_10
    600                  case cJSON_Array:
    601                      out = print_array(item, depth, fmt, 0);
   \                     ??print_value_20: (+1)
   \   000000F6   0x2300             MOVS     R3,#+0
   \   000000F8   0x.... 0x....      BL       print_array
   \   000000FC   0x0004             MOVS     R4,R0
    602                      break;
   \   000000FE   0xE003             B.N      ??print_value_10
    603                  case cJSON_Object:
    604                      out = print_object(item, depth, fmt, 0);
   \                     ??print_value_19: (+1)
   \   00000100   0x2300             MOVS     R3,#+0
   \   00000102   0x.... 0x....      BL       print_object
   \   00000106   0x0004             MOVS     R4,R0
    605                      break;
    606                  }
    607              }
    608              return out;
   \                     ??print_value_10: (+1)
   \   00000108   0x0020             MOVS     R0,R4
   \                     ??print_value_1: (+1)
   \   0000010A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    609          }
    610          
    611          /* Build an array from input text. */

   \                                 In section .text, align 2, keep-with-next
    612          static const char *parse_array(cJSON *item, const char *value)
    613          {
   \                     parse_array: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000C             MOVS     R4,R1
    614              cJSON *child;
    615              if (*value != '[')
   \   00000006   0x7820             LDRB     R0,[R4, #+0]
   \   00000008   0x285B             CMP      R0,#+91
   \   0000000A   0xD003             BEQ.N    ??parse_array_0
    616              {
    617                  ep = value;    /* not an array! */
   \   0000000C   0x....             LDR.N    R0,??DataTable14
   \   0000000E   0x6004             STR      R4,[R0, #+0]
    618                  return 0;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xE043             B.N      ??parse_array_1
    619              }
    620          
    621              item->type = cJSON_Array;
   \                     ??parse_array_0: (+1)
   \   00000014   0x2005             MOVS     R0,#+5
   \   00000016   0x60E8             STR      R0,[R5, #+12]
    622              value = skip(value + 1);
   \   00000018   0x1C60             ADDS     R0,R4,#+1
   \   0000001A   0x.... 0x....      BL       skip
   \   0000001E   0x0004             MOVS     R4,R0
    623              if (*value == ']') return value + 1;	/* empty array. */
   \   00000020   0x7820             LDRB     R0,[R4, #+0]
   \   00000022   0x285D             CMP      R0,#+93
   \   00000024   0xD101             BNE.N    ??parse_array_2
   \   00000026   0x1C60             ADDS     R0,R4,#+1
   \   00000028   0xE038             B.N      ??parse_array_1
    624          
    625              item->child = child = cJSON_New_Item();
   \                     ??parse_array_2: (+1)
   \   0000002A   0x.... 0x....      BL       cJSON_New_Item
   \   0000002E   0x0006             MOVS     R6,R0
   \   00000030   0x60AE             STR      R6,[R5, #+8]
    626              if (!item->child) return 0;		 /* memory fail */
   \   00000032   0x68A8             LDR      R0,[R5, #+8]
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD101             BNE.N    ??parse_array_3
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0xE02F             B.N      ??parse_array_1
    627              value = skip(parse_value(child, skip(value)));	/* skip any spacing, get the value. */
   \                     ??parse_array_3: (+1)
   \   0000003C   0x0020             MOVS     R0,R4
   \   0000003E   0x.... 0x....      BL       skip
   \   00000042   0x0001             MOVS     R1,R0
   \   00000044   0x0030             MOVS     R0,R6
   \   00000046   0x.... 0x....      BL       parse_value
   \   0000004A   0x.... 0x....      BL       skip
   \   0000004E   0x0004             MOVS     R4,R0
    628              if (!value) return 0;
   \   00000050   0x2C00             CMP      R4,#+0
   \   00000052   0xD101             BNE.N    ??parse_array_4
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0xE021             B.N      ??parse_array_1
    629          
    630              while (*value == ',')
   \                     ??parse_array_4: (+1)
   \   00000058   0x7820             LDRB     R0,[R4, #+0]
   \   0000005A   0x282C             CMP      R0,#+44
   \   0000005C   0xD116             BNE.N    ??parse_array_5
    631              {
    632                  cJSON *new_item;
    633                  if (!(new_item = cJSON_New_Item())) return 0; 	/* memory fail */
   \   0000005E   0x.... 0x....      BL       cJSON_New_Item
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD101             BNE.N    ??parse_array_6
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0xE018             B.N      ??parse_array_1
    634                  child->next = new_item;
   \                     ??parse_array_6: (+1)
   \   0000006A   0x6030             STR      R0,[R6, #+0]
    635                  new_item->prev = child;
   \   0000006C   0x6046             STR      R6,[R0, #+4]
    636                  child = new_item;
   \   0000006E   0x0006             MOVS     R6,R0
    637                  value = skip(parse_value(child, skip(value + 1)));
   \   00000070   0x1C60             ADDS     R0,R4,#+1
   \   00000072   0x.... 0x....      BL       skip
   \   00000076   0x0001             MOVS     R1,R0
   \   00000078   0x0030             MOVS     R0,R6
   \   0000007A   0x.... 0x....      BL       parse_value
   \   0000007E   0x.... 0x....      BL       skip
   \   00000082   0x0004             MOVS     R4,R0
    638                  if (!value) return 0;	/* memory fail */
   \   00000084   0x2C00             CMP      R4,#+0
   \   00000086   0xD1E7             BNE.N    ??parse_array_4
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0xE007             B.N      ??parse_array_1
    639              }
    640          
    641              if (*value == ']') return value + 1;	/* end of array */
   \                     ??parse_array_5: (+1)
   \   0000008C   0x7820             LDRB     R0,[R4, #+0]
   \   0000008E   0x285D             CMP      R0,#+93
   \   00000090   0xD101             BNE.N    ??parse_array_7
   \   00000092   0x1C60             ADDS     R0,R4,#+1
   \   00000094   0xE002             B.N      ??parse_array_1
    642              ep = value;
   \                     ??parse_array_7: (+1)
   \   00000096   0x....             LDR.N    R0,??DataTable14
   \   00000098   0x6004             STR      R4,[R0, #+0]
    643              return 0;	/* malformed. */
   \   0000009A   0x2000             MOVS     R0,#+0
   \                     ??parse_array_1: (+1)
   \   0000009C   0xBD70             POP      {R4-R6,PC}       ;; return
    644          }
    645          
    646          /* Render an array to text */

   \                                 In section .text, align 2, keep-with-next
    647          static char *print_array(cJSON *item, int depth, int fmt, printbuffer *p)
    648          {
   \                     print_array: (+1)
   \   00000000   0xE92D 0x4FFF      PUSH     {R0-R11,LR}
   \   00000004   0xB081             SUB      SP,SP,#+4
    649              char **entries;
    650              char *out = 0, *ptr, *ret;
   \   00000006   0x2700             MOVS     R7,#+0
    651              int len = 5;
   \   00000008   0x2605             MOVS     R6,#+5
    652              cJSON *child = item->child;
   \   0000000A   0x9801             LDR      R0,[SP, #+4]
   \   0000000C   0xF8D0 0x9008      LDR      R9,[R0, #+8]
    653              int numentries = 0, i = 0, fail = 0;
   \   00000010   0xF05F 0x0800      MOVS     R8,#+0
   \   00000014   0x2500             MOVS     R5,#+0
   \   00000016   0x2400             MOVS     R4,#+0
    654              size_t tmplen = 0;
   \   00000018   0xF05F 0x0B00      MOVS     R11,#+0
   \   0000001C   0xE003             B.N      ??print_array_0
    655          
    656              /* How many entries in the array? */
    657              while (child) numentries++, child = child->next;
   \                     ??print_array_1: (+1)
   \   0000001E   0xF118 0x0801      ADDS     R8,R8,#+1
   \   00000022   0xF8D9 0x9000      LDR      R9,[R9, #+0]
   \                     ??print_array_0: (+1)
   \   00000026   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000002A   0xD1F8             BNE.N    ??print_array_1
    658              /* Explicitly handle numentries==0 */
    659              if (!numentries)
   \   0000002C   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000030   0xD116             BNE.N    ??print_array_2
    660              {
    661                  if (p)	out = ensure(p, 3);
   \   00000032   0x9804             LDR      R0,[SP, #+16]
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD005             BEQ.N    ??print_array_3
   \   00000038   0x2103             MOVS     R1,#+3
   \   0000003A   0x9804             LDR      R0,[SP, #+16]
   \   0000003C   0x.... 0x....      BL       ensure
   \   00000040   0x0007             MOVS     R7,R0
   \   00000042   0xE005             B.N      ??print_array_4
    662                  else	out = (char *)cJSON_malloc(3);
   \                     ??print_array_3: (+1)
   \   00000044   0x2003             MOVS     R0,#+3
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable19_1
   \   0000004A   0x6809             LDR      R1,[R1, #+0]
   \   0000004C   0x4788             BLX      R1
   \   0000004E   0x0007             MOVS     R7,R0
    663                  if (out) strcpy(out, "[]");
   \                     ??print_array_4: (+1)
   \   00000050   0x2F00             CMP      R7,#+0
   \   00000052   0xD003             BEQ.N    ??print_array_5
   \   00000054   0x....             ADR.N    R1,??DataTable15  ;; 0x5B, 0x5D, 0x00, 0x00
   \   00000056   0x0038             MOVS     R0,R7
   \   00000058   0x.... 0x....      BL       strcpy
    664                  return out;
   \                     ??print_array_5: (+1)
   \   0000005C   0x0038             MOVS     R0,R7
   \   0000005E   0xE10E             B.N      ??print_array_6
    665              }
    666          
    667              if (p)
   \                     ??print_array_2: (+1)
   \   00000060   0x9804             LDR      R0,[SP, #+16]
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD069             BEQ.N    ??print_array_7
    668              {
    669                  /* Compose the output array. */
    670                  i = p->offset;
   \   00000066   0x9804             LDR      R0,[SP, #+16]
   \   00000068   0x6885             LDR      R5,[R0, #+8]
    671                  ptr = ensure(p, 1);
   \   0000006A   0x2101             MOVS     R1,#+1
   \   0000006C   0x9804             LDR      R0,[SP, #+16]
   \   0000006E   0x.... 0x....      BL       ensure
   \   00000072   0x4682             MOV      R10,R0
    672                  if (!ptr) return 0;
   \   00000074   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000078   0xD101             BNE.N    ??print_array_8
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0xE0FF             B.N      ??print_array_6
    673                  *ptr = '[';
   \                     ??print_array_8: (+1)
   \   0000007E   0x205B             MOVS     R0,#+91
   \   00000080   0xF88A 0x0000      STRB     R0,[R10, #+0]
    674                  p->offset++;
   \   00000084   0x9804             LDR      R0,[SP, #+16]
   \   00000086   0x6880             LDR      R0,[R0, #+8]
   \   00000088   0x1C40             ADDS     R0,R0,#+1
   \   0000008A   0x9904             LDR      R1,[SP, #+16]
   \   0000008C   0x6088             STR      R0,[R1, #+8]
    675                  child = item->child;
   \   0000008E   0x9801             LDR      R0,[SP, #+4]
   \   00000090   0xF8D0 0x9008      LDR      R9,[R0, #+8]
   \   00000094   0xE016             B.N      ??print_array_9
    676                  while (child && !fail)
    677                  {
    678                      print_value(child, depth + 1, fmt, p);
    679                      p->offset = update(p);
    680                      if (child->next)
    681                      {
    682                          len = fmt ? 2 : 1;
    683                          ptr = ensure(p, len + 1);
    684                          if (!ptr) return 0;
    685                          *ptr++ = ',';
   \                     ??print_array_10: (+1)
   \   00000096   0x202C             MOVS     R0,#+44
   \   00000098   0xF88A 0x0000      STRB     R0,[R10, #+0]
   \   0000009C   0xF11A 0x0A01      ADDS     R10,R10,#+1
    686                          if(fmt)*ptr++ = ' ';
   \   000000A0   0x9803             LDR      R0,[SP, #+12]
   \   000000A2   0x2800             CMP      R0,#+0
   \   000000A4   0xD004             BEQ.N    ??print_array_11
   \   000000A6   0x2020             MOVS     R0,#+32
   \   000000A8   0xF88A 0x0000      STRB     R0,[R10, #+0]
   \   000000AC   0xF11A 0x0A01      ADDS     R10,R10,#+1
    687                          *ptr = 0;
   \                     ??print_array_11: (+1)
   \   000000B0   0x2000             MOVS     R0,#+0
   \   000000B2   0xF88A 0x0000      STRB     R0,[R10, #+0]
    688                          p->offset += len;
   \   000000B6   0x9804             LDR      R0,[SP, #+16]
   \   000000B8   0x6880             LDR      R0,[R0, #+8]
   \   000000BA   0x1830             ADDS     R0,R6,R0
   \   000000BC   0x9904             LDR      R1,[SP, #+16]
   \   000000BE   0x6088             STR      R0,[R1, #+8]
    689                      }
    690                      child = child->next;
   \                     ??print_array_12: (+1)
   \   000000C0   0xF8D9 0x9000      LDR      R9,[R9, #+0]
   \                     ??print_array_9: (+1)
   \   000000C4   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000C8   0xD021             BEQ.N    ??print_array_13
   \   000000CA   0x2C00             CMP      R4,#+0
   \   000000CC   0xD11F             BNE.N    ??print_array_13
   \   000000CE   0x9B04             LDR      R3,[SP, #+16]
   \   000000D0   0x9A03             LDR      R2,[SP, #+12]
   \   000000D2   0x9802             LDR      R0,[SP, #+8]
   \   000000D4   0x1C41             ADDS     R1,R0,#+1
   \   000000D6   0x4648             MOV      R0,R9
   \   000000D8   0x.... 0x....      BL       print_value
   \   000000DC   0x9804             LDR      R0,[SP, #+16]
   \   000000DE   0x.... 0x....      BL       update
   \   000000E2   0x9904             LDR      R1,[SP, #+16]
   \   000000E4   0x6088             STR      R0,[R1, #+8]
   \   000000E6   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \   000000EA   0x2800             CMP      R0,#+0
   \   000000EC   0xD0E8             BEQ.N    ??print_array_12
   \   000000EE   0x9803             LDR      R0,[SP, #+12]
   \   000000F0   0x2800             CMP      R0,#+0
   \   000000F2   0xD001             BEQ.N    ??print_array_14
   \   000000F4   0x2602             MOVS     R6,#+2
   \   000000F6   0xE000             B.N      ??print_array_15
   \                     ??print_array_14: (+1)
   \   000000F8   0x2601             MOVS     R6,#+1
   \                     ??print_array_15: (+1)
   \   000000FA   0x1C71             ADDS     R1,R6,#+1
   \   000000FC   0x9804             LDR      R0,[SP, #+16]
   \   000000FE   0x.... 0x....      BL       ensure
   \   00000102   0x4682             MOV      R10,R0
   \   00000104   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000108   0xD1C5             BNE.N    ??print_array_10
   \   0000010A   0x2000             MOVS     R0,#+0
   \   0000010C   0xE0B7             B.N      ??print_array_6
    691                  }
    692                  ptr = ensure(p, 2);
   \                     ??print_array_13: (+1)
   \   0000010E   0x2102             MOVS     R1,#+2
   \   00000110   0x9804             LDR      R0,[SP, #+16]
   \   00000112   0x.... 0x....      BL       ensure
   \   00000116   0x4682             MOV      R10,R0
    693                  if (!ptr) return 0;
   \   00000118   0xF1BA 0x0F00      CMP      R10,#+0
   \   0000011C   0xD101             BNE.N    ??print_array_16
   \   0000011E   0x2000             MOVS     R0,#+0
   \   00000120   0xE0AD             B.N      ??print_array_6
    694                  *ptr++ = ']';
   \                     ??print_array_16: (+1)
   \   00000122   0x205D             MOVS     R0,#+93
   \   00000124   0xF88A 0x0000      STRB     R0,[R10, #+0]
   \   00000128   0xF11A 0x0A01      ADDS     R10,R10,#+1
    695                  *ptr = 0;
   \   0000012C   0x2000             MOVS     R0,#+0
   \   0000012E   0xF88A 0x0000      STRB     R0,[R10, #+0]
    696                  out = (p->buffer) + i;
   \   00000132   0x9804             LDR      R0,[SP, #+16]
   \   00000134   0x6800             LDR      R0,[R0, #+0]
   \   00000136   0x182F             ADDS     R7,R5,R0
   \   00000138   0xE0A0             B.N      ??print_array_17
    697              }
    698              else
    699              {
    700                  /* Allocate an array to hold the values for each */
    701                  entries = (char **)cJSON_malloc(numentries * sizeof(char *));
   \                     ??print_array_7: (+1)
   \   0000013A   0xEA5F 0x0088      LSLS     R0,R8,#+2
   \   0000013E   0x.... 0x....      LDR.W    R1,??DataTable19_1
   \   00000142   0x6809             LDR      R1,[R1, #+0]
   \   00000144   0x4788             BLX      R1
   \   00000146   0x9000             STR      R0,[SP, #+0]
    702                  if (!entries) return 0;
   \   00000148   0x9800             LDR      R0,[SP, #+0]
   \   0000014A   0x2800             CMP      R0,#+0
   \   0000014C   0xD101             BNE.N    ??print_array_18
   \   0000014E   0x2000             MOVS     R0,#+0
   \   00000150   0xE095             B.N      ??print_array_6
    703                  memset(entries, 0, numentries * sizeof(char *));
   \                     ??print_array_18: (+1)
   \   00000152   0xEA5F 0x0288      LSLS     R2,R8,#+2
   \   00000156   0x2100             MOVS     R1,#+0
   \   00000158   0x9800             LDR      R0,[SP, #+0]
   \   0000015A   0x.... 0x....      BL       memset
    704                  /* Retrieve all the results: */
    705                  child = item->child;
   \   0000015E   0x9801             LDR      R0,[SP, #+4]
   \   00000160   0xF8D0 0x9008      LDR      R9,[R0, #+8]
   \   00000164   0xE002             B.N      ??print_array_19
    706                  while (child && !fail)
    707                  {
    708                      ret = print_value(child, depth + 1, fmt, 0);
    709                      entries[i++] = ret;
    710                      if (ret) len += strlen(ret) + 2 + (fmt ? 1 : 0);
    711                      else fail = 1;
   \                     ??print_array_20: (+1)
   \   00000166   0x2401             MOVS     R4,#+1
    712                      child = child->next;
   \                     ??print_array_21: (+1)
   \   00000168   0xF8D9 0x9000      LDR      R9,[R9, #+0]
   \                     ??print_array_19: (+1)
   \   0000016C   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000170   0xD01A             BEQ.N    ??print_array_22
   \   00000172   0x2C00             CMP      R4,#+0
   \   00000174   0xD118             BNE.N    ??print_array_22
   \   00000176   0x2300             MOVS     R3,#+0
   \   00000178   0x9A03             LDR      R2,[SP, #+12]
   \   0000017A   0x9802             LDR      R0,[SP, #+8]
   \   0000017C   0x1C41             ADDS     R1,R0,#+1
   \   0000017E   0x4648             MOV      R0,R9
   \   00000180   0x.... 0x....      BL       print_value
   \   00000184   0x9900             LDR      R1,[SP, #+0]
   \   00000186   0xF841 0x0025      STR      R0,[R1, R5, LSL #+2]
   \   0000018A   0x1C6D             ADDS     R5,R5,#+1
   \   0000018C   0x2800             CMP      R0,#+0
   \   0000018E   0xD0EA             BEQ.N    ??print_array_20
   \   00000190   0x.... 0x....      BL       strlen
   \   00000194   0x9903             LDR      R1,[SP, #+12]
   \   00000196   0x2900             CMP      R1,#+0
   \   00000198   0xD001             BEQ.N    ??print_array_23
   \   0000019A   0x2101             MOVS     R1,#+1
   \   0000019C   0xE000             B.N      ??print_array_24
   \                     ??print_array_23: (+1)
   \   0000019E   0x2100             MOVS     R1,#+0
   \                     ??print_array_24: (+1)
   \   000001A0   0x1808             ADDS     R0,R1,R0
   \   000001A2   0x1C80             ADDS     R0,R0,#+2
   \   000001A4   0x1986             ADDS     R6,R0,R6
   \   000001A6   0xE7DF             B.N      ??print_array_21
    713                  }
    714          
    715                  /* If we didn't fail, try to malloc the output string */
    716                  if (!fail)	out = (char *)cJSON_malloc(len);
   \                     ??print_array_22: (+1)
   \   000001A8   0x2C00             CMP      R4,#+0
   \   000001AA   0xD105             BNE.N    ??print_array_25
   \   000001AC   0x0030             MOVS     R0,R6
   \   000001AE   0x.... 0x....      LDR.W    R1,??DataTable19_1
   \   000001B2   0x6809             LDR      R1,[R1, #+0]
   \   000001B4   0x4788             BLX      R1
   \   000001B6   0x0007             MOVS     R7,R0
    717                  /* If that fails, we fail. */
    718                  if (!out) fail = 1;
   \                     ??print_array_25: (+1)
   \   000001B8   0x2F00             CMP      R7,#+0
   \   000001BA   0xD100             BNE.N    ??print_array_26
   \   000001BC   0x2401             MOVS     R4,#+1
    719          
    720                  /* Handle failure. */
    721                  if (fail)
   \                     ??print_array_26: (+1)
   \   000001BE   0x2C00             CMP      R4,#+0
   \   000001C0   0xD017             BEQ.N    ??print_array_27
    722                  {
    723                      for (i = 0; i < numentries; i++) if (entries[i]) cJSON_free(entries[i]);
   \   000001C2   0x2500             MOVS     R5,#+0
   \   000001C4   0xE00C             B.N      ??print_array_28
   \                     ??print_array_29: (+1)
   \   000001C6   0x9800             LDR      R0,[SP, #+0]
   \   000001C8   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   000001CC   0x2800             CMP      R0,#+0
   \   000001CE   0xD006             BEQ.N    ??print_array_30
   \   000001D0   0x9800             LDR      R0,[SP, #+0]
   \   000001D2   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   000001D6   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   000001DA   0x6809             LDR      R1,[R1, #+0]
   \   000001DC   0x4788             BLX      R1
   \                     ??print_array_30: (+1)
   \   000001DE   0x1C6D             ADDS     R5,R5,#+1
   \                     ??print_array_28: (+1)
   \   000001E0   0x4545             CMP      R5,R8
   \   000001E2   0xDBF0             BLT.N    ??print_array_29
    724                      cJSON_free(entries);
   \   000001E4   0x9800             LDR      R0,[SP, #+0]
   \   000001E6   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   000001EA   0x6809             LDR      R1,[R1, #+0]
   \   000001EC   0x4788             BLX      R1
    725                      return 0;
   \   000001EE   0x2000             MOVS     R0,#+0
   \   000001F0   0xE045             B.N      ??print_array_6
    726                  }
    727          
    728                  /* Compose the output array. */
    729                  *out = '[';
   \                     ??print_array_27: (+1)
   \   000001F2   0x205B             MOVS     R0,#+91
   \   000001F4   0x7038             STRB     R0,[R7, #+0]
    730                  ptr = out + 1;
   \   000001F6   0xF117 0x0A01      ADDS     R10,R7,#+1
    731                  *ptr = 0;
   \   000001FA   0x2000             MOVS     R0,#+0
   \   000001FC   0xF88A 0x0000      STRB     R0,[R10, #+0]
    732                  for (i = 0; i < numentries; i++)
   \   00000200   0x2500             MOVS     R5,#+0
   \   00000202   0xE02A             B.N      ??print_array_31
    733                  {
    734                      tmplen = strlen(entries[i]);
   \                     ??print_array_32: (+1)
   \   00000204   0x9800             LDR      R0,[SP, #+0]
   \   00000206   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   0000020A   0x.... 0x....      BL       strlen
   \   0000020E   0x4683             MOV      R11,R0
    735                      memcpy(ptr, entries[i], tmplen);
   \   00000210   0x465A             MOV      R2,R11
   \   00000212   0x9800             LDR      R0,[SP, #+0]
   \   00000214   0xF850 0x1025      LDR      R1,[R0, R5, LSL #+2]
   \   00000218   0x4650             MOV      R0,R10
   \   0000021A   0x.... 0x....      BL       memcpy
    736                      ptr += tmplen;
   \   0000021E   0xEB1B 0x0A0A      ADDS     R10,R11,R10
    737                      if (i != numentries - 1)
   \   00000222   0xF1B8 0x0001      SUBS     R0,R8,#+1
   \   00000226   0x4285             CMP      R5,R0
   \   00000228   0xD00F             BEQ.N    ??print_array_33
    738                      {
    739                          *ptr++ = ',';
   \   0000022A   0x202C             MOVS     R0,#+44
   \   0000022C   0xF88A 0x0000      STRB     R0,[R10, #+0]
   \   00000230   0xF11A 0x0A01      ADDS     R10,R10,#+1
    740                          if(fmt)*ptr++ = ' ';
   \   00000234   0x9803             LDR      R0,[SP, #+12]
   \   00000236   0x2800             CMP      R0,#+0
   \   00000238   0xD004             BEQ.N    ??print_array_34
   \   0000023A   0x2020             MOVS     R0,#+32
   \   0000023C   0xF88A 0x0000      STRB     R0,[R10, #+0]
   \   00000240   0xF11A 0x0A01      ADDS     R10,R10,#+1
    741                          *ptr = 0;
   \                     ??print_array_34: (+1)
   \   00000244   0x2000             MOVS     R0,#+0
   \   00000246   0xF88A 0x0000      STRB     R0,[R10, #+0]
    742                      }
    743                      cJSON_free(entries[i]);
   \                     ??print_array_33: (+1)
   \   0000024A   0x9800             LDR      R0,[SP, #+0]
   \   0000024C   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   00000250   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   00000254   0x6809             LDR      R1,[R1, #+0]
   \   00000256   0x4788             BLX      R1
    744                  }
   \   00000258   0x1C6D             ADDS     R5,R5,#+1
   \                     ??print_array_31: (+1)
   \   0000025A   0x4545             CMP      R5,R8
   \   0000025C   0xDBD2             BLT.N    ??print_array_32
    745                  cJSON_free(entries);
   \   0000025E   0x9800             LDR      R0,[SP, #+0]
   \   00000260   0x.... 0x....      LDR.W    R1,??DataTable19_5
   \   00000264   0x6809             LDR      R1,[R1, #+0]
   \   00000266   0x4788             BLX      R1
    746                  *ptr++ = ']';
   \   00000268   0x205D             MOVS     R0,#+93
   \   0000026A   0xF88A 0x0000      STRB     R0,[R10, #+0]
   \   0000026E   0xF11A 0x0A01      ADDS     R10,R10,#+1
    747                  *ptr++ = 0;
   \   00000272   0x2000             MOVS     R0,#+0
   \   00000274   0xF88A 0x0000      STRB     R0,[R10, #+0]
   \   00000278   0xF11A 0x0A01      ADDS     R10,R10,#+1
    748              }
    749              return out;
   \                     ??print_array_17: (+1)
   \   0000027C   0x0038             MOVS     R0,R7
   \                     ??print_array_6: (+1)
   \   0000027E   0xB005             ADD      SP,SP,#+20
   \   00000280   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    750          }
    751          
    752          /* Build an object from the text. */

   \                                 In section .text, align 2, keep-with-next
    753          static const char *parse_object(cJSON *item, const char *value)
    754          {
   \                     parse_object: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0006             MOVS     R6,R0
   \   00000004   0x000D             MOVS     R5,R1
    755              cJSON *child;
    756              if (*value != '{')
   \   00000006   0x7828             LDRB     R0,[R5, #+0]
   \   00000008   0x287B             CMP      R0,#+123
   \   0000000A   0xD003             BEQ.N    ??parse_object_0
    757              {
    758                  ep = value;    /* not an object! */
   \   0000000C   0x....             LDR.N    R0,??DataTable16_11
   \   0000000E   0x6005             STR      R5,[R0, #+0]
    759                  return 0;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xE075             B.N      ??parse_object_1
    760              }
    761          
    762              item->type = cJSON_Object;
   \                     ??parse_object_0: (+1)
   \   00000014   0x2006             MOVS     R0,#+6
   \   00000016   0x60F0             STR      R0,[R6, #+12]
    763              value = skip(value + 1);
   \   00000018   0x1C68             ADDS     R0,R5,#+1
   \   0000001A   0x.... 0x....      BL       skip
   \   0000001E   0x0005             MOVS     R5,R0
    764              if (*value == '}') return value + 1;	/* empty array. */
   \   00000020   0x7828             LDRB     R0,[R5, #+0]
   \   00000022   0x287D             CMP      R0,#+125
   \   00000024   0xD101             BNE.N    ??parse_object_2
   \   00000026   0x1C68             ADDS     R0,R5,#+1
   \   00000028   0xE06A             B.N      ??parse_object_1
    765          
    766              item->child = child = cJSON_New_Item();
   \                     ??parse_object_2: (+1)
   \   0000002A   0x.... 0x....      BL       cJSON_New_Item
   \   0000002E   0x0004             MOVS     R4,R0
   \   00000030   0x60B4             STR      R4,[R6, #+8]
    767              if (!item->child) return 0;
   \   00000032   0x68B0             LDR      R0,[R6, #+8]
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD101             BNE.N    ??parse_object_3
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0xE061             B.N      ??parse_object_1
    768              value = skip(parse_string(child, skip(value)));
   \                     ??parse_object_3: (+1)
   \   0000003C   0x0028             MOVS     R0,R5
   \   0000003E   0x.... 0x....      BL       skip
   \   00000042   0x0001             MOVS     R1,R0
   \   00000044   0x0020             MOVS     R0,R4
   \   00000046   0x.... 0x....      BL       parse_string
   \   0000004A   0x.... 0x....      BL       skip
   \   0000004E   0x0005             MOVS     R5,R0
    769              if (!value) return 0;
   \   00000050   0x2D00             CMP      R5,#+0
   \   00000052   0xD101             BNE.N    ??parse_object_4
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0xE053             B.N      ??parse_object_1
    770              child->string = child->valuestring;
   \                     ??parse_object_4: (+1)
   \   00000058   0x6920             LDR      R0,[R4, #+16]
   \   0000005A   0x6220             STR      R0,[R4, #+32]
    771              child->valuestring = 0;
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x6120             STR      R0,[R4, #+16]
    772              if (*value != ':')
   \   00000060   0x7828             LDRB     R0,[R5, #+0]
   \   00000062   0x283A             CMP      R0,#+58
   \   00000064   0xD003             BEQ.N    ??parse_object_5
    773              {
    774                  ep = value;    /* fail! */
   \   00000066   0x....             LDR.N    R0,??DataTable16_11
   \   00000068   0x6005             STR      R5,[R0, #+0]
    775                  return 0;
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0xE048             B.N      ??parse_object_1
    776              }
    777              value = skip(parse_value(child, skip(value + 1)));	/* skip any spacing, get the value. */
   \                     ??parse_object_5: (+1)
   \   0000006E   0x1C68             ADDS     R0,R5,#+1
   \   00000070   0x.... 0x....      BL       skip
   \   00000074   0x0001             MOVS     R1,R0
   \   00000076   0x0020             MOVS     R0,R4
   \   00000078   0x.... 0x....      BL       parse_value
   \   0000007C   0x.... 0x....      BL       skip
   \   00000080   0x0005             MOVS     R5,R0
    778              if (!value) return 0;
   \   00000082   0x2D00             CMP      R5,#+0
   \   00000084   0xD101             BNE.N    ??parse_object_6
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0xE03A             B.N      ??parse_object_1
    779          
    780              while (*value == ',')
   \                     ??parse_object_6: (+1)
   \   0000008A   0x7828             LDRB     R0,[R5, #+0]
   \   0000008C   0x282C             CMP      R0,#+44
   \   0000008E   0xD12F             BNE.N    ??parse_object_7
    781              {
    782                  cJSON *new_item;
    783                  if (!(new_item = cJSON_New_Item()))	return 0; /* memory fail */
   \   00000090   0x.... 0x....      BL       cJSON_New_Item
   \   00000094   0x2800             CMP      R0,#+0
   \   00000096   0xD101             BNE.N    ??parse_object_8
   \   00000098   0x2000             MOVS     R0,#+0
   \   0000009A   0xE031             B.N      ??parse_object_1
    784                  child->next = new_item;
   \                     ??parse_object_8: (+1)
   \   0000009C   0x6020             STR      R0,[R4, #+0]
    785                  new_item->prev = child;
   \   0000009E   0x6044             STR      R4,[R0, #+4]
    786                  child = new_item;
   \   000000A0   0x0004             MOVS     R4,R0
    787                  value = skip(parse_string(child, skip(value + 1)));
   \   000000A2   0x1C68             ADDS     R0,R5,#+1
   \   000000A4   0x.... 0x....      BL       skip
   \   000000A8   0x0001             MOVS     R1,R0
   \   000000AA   0x0020             MOVS     R0,R4
   \   000000AC   0x.... 0x....      BL       parse_string
   \   000000B0   0x.... 0x....      BL       skip
   \   000000B4   0x0005             MOVS     R5,R0
    788                  if (!value) return 0;
   \   000000B6   0x2D00             CMP      R5,#+0
   \   000000B8   0xD101             BNE.N    ??parse_object_9
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0xE020             B.N      ??parse_object_1
    789                  child->string = child->valuestring;
   \                     ??parse_object_9: (+1)
   \   000000BE   0x6920             LDR      R0,[R4, #+16]
   \   000000C0   0x6220             STR      R0,[R4, #+32]
    790                  child->valuestring = 0;
   \   000000C2   0x2000             MOVS     R0,#+0
   \   000000C4   0x6120             STR      R0,[R4, #+16]
    791                  if (*value != ':')
   \   000000C6   0x7828             LDRB     R0,[R5, #+0]
   \   000000C8   0x283A             CMP      R0,#+58
   \   000000CA   0xD003             BEQ.N    ??parse_object_10
    792                  {
    793                      ep = value;    /* fail! */
   \   000000CC   0x....             LDR.N    R0,??DataTable16_11
   \   000000CE   0x6005             STR      R5,[R0, #+0]
    794                      return 0;
   \   000000D0   0x2000             MOVS     R0,#+0
   \   000000D2   0xE015             B.N      ??parse_object_1
    795                  }
    796                  value = skip(parse_value(child, skip(value + 1)));	/* skip any spacing, get the value. */
   \                     ??parse_object_10: (+1)
   \   000000D4   0x1C68             ADDS     R0,R5,#+1
   \   000000D6   0x.... 0x....      BL       skip
   \   000000DA   0x0001             MOVS     R1,R0
   \   000000DC   0x0020             MOVS     R0,R4
   \   000000DE   0x.... 0x....      BL       parse_value
   \   000000E2   0x.... 0x....      BL       skip
   \   000000E6   0x0005             MOVS     R5,R0
    797                  if (!value) return 0;
   \   000000E8   0x2D00             CMP      R5,#+0
   \   000000EA   0xD1CE             BNE.N    ??parse_object_6
   \   000000EC   0x2000             MOVS     R0,#+0
   \   000000EE   0xE007             B.N      ??parse_object_1
    798              }
    799          
    800              if (*value == '}') return value + 1;	/* end of array */
   \                     ??parse_object_7: (+1)
   \   000000F0   0x7828             LDRB     R0,[R5, #+0]
   \   000000F2   0x287D             CMP      R0,#+125
   \   000000F4   0xD101             BNE.N    ??parse_object_11
   \   000000F6   0x1C68             ADDS     R0,R5,#+1
   \   000000F8   0xE002             B.N      ??parse_object_1
    801              ep = value;
   \                     ??parse_object_11: (+1)
   \   000000FA   0x....             LDR.N    R0,??DataTable16_11
   \   000000FC   0x6005             STR      R5,[R0, #+0]
    802              return 0;	/* malformed. */
   \   000000FE   0x2000             MOVS     R0,#+0
   \                     ??parse_object_1: (+1)
   \   00000100   0xBD70             POP      {R4-R6,PC}       ;; return
    803          }
    804          
    805          /* Render an object to text. */

   \                                 In section .text, align 2, keep-with-next
    806          static char *print_object(cJSON *item, int depth, int fmt, printbuffer *p)
    807          {
   \                     print_object: (+1)
   \   00000000   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \   00000004   0xB086             SUB      SP,SP,#+24
   \   00000006   0x000C             MOVS     R4,R1
   \   00000008   0x0015             MOVS     R5,R2
   \   0000000A   0x469B             MOV      R11,R3
    808              char **entries = 0, **names = 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x9000             STR      R0,[SP, #+0]
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x9001             STR      R0,[SP, #+4]
    809              char *out = 0, *ptr, *ret, *str;
   \   00000014   0x2600             MOVS     R6,#+0
    810              int len = 7, i = 0, j;
   \   00000016   0x2707             MOVS     R7,#+7
   \   00000018   0xF05F 0x0800      MOVS     R8,#+0
    811              cJSON *child = item->child;
   \   0000001C   0x9806             LDR      R0,[SP, #+24]
   \   0000001E   0xF8D0 0x9008      LDR      R9,[R0, #+8]
    812              int numentries = 0, fail = 0;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x9002             STR      R0,[SP, #+8]
   \   00000026   0xF05F 0x0A00      MOVS     R10,#+0
    813              size_t tmplen = 0;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x9003             STR      R0,[SP, #+12]
   \   0000002E   0xE004             B.N      ??print_object_0
    814              /* Count the number of entries. */
    815              while (child) numentries++, child = child->next;
   \                     ??print_object_1: (+1)
   \   00000030   0x9802             LDR      R0,[SP, #+8]
   \   00000032   0x1C40             ADDS     R0,R0,#+1
   \   00000034   0x9002             STR      R0,[SP, #+8]
   \   00000036   0xF8D9 0x9000      LDR      R9,[R9, #+0]
   \                     ??print_object_0: (+1)
   \   0000003A   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000003E   0xD1F7             BNE.N    ??print_object_1
    816              /* Explicitly handle empty object case */
    817              if (!numentries)
   \   00000040   0x9802             LDR      R0,[SP, #+8]
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD140             BNE.N    ??print_object_2
    818              {
    819                  if (p) out = ensure(p, fmt ? depth + 4 : 3);
   \   00000046   0xF1BB 0x0F00      CMP      R11,#+0
   \   0000004A   0xD009             BEQ.N    ??print_object_3
   \   0000004C   0x2D00             CMP      R5,#+0
   \   0000004E   0xD001             BEQ.N    ??print_object_4
   \   00000050   0x1D21             ADDS     R1,R4,#+4
   \   00000052   0xE000             B.N      ??print_object_5
   \                     ??print_object_4: (+1)
   \   00000054   0x2103             MOVS     R1,#+3
   \                     ??print_object_5: (+1)
   \   00000056   0x4658             MOV      R0,R11
   \   00000058   0x.... 0x....      BL       ensure
   \   0000005C   0x0006             MOVS     R6,R0
   \   0000005E   0xE009             B.N      ??print_object_6
    820                  else	out = (char *)cJSON_malloc(fmt ? depth + 4 : 3);
   \                     ??print_object_3: (+1)
   \   00000060   0x2D00             CMP      R5,#+0
   \   00000062   0xD001             BEQ.N    ??print_object_7
   \   00000064   0x1D20             ADDS     R0,R4,#+4
   \   00000066   0xE000             B.N      ??print_object_8
   \                     ??print_object_7: (+1)
   \   00000068   0x2003             MOVS     R0,#+3
   \                     ??print_object_8: (+1)
   \   0000006A   0x.... 0x....      LDR.W    R1,??DataTable19_1
   \   0000006E   0x6809             LDR      R1,[R1, #+0]
   \   00000070   0x4788             BLX      R1
   \   00000072   0x0006             MOVS     R6,R0
    821                  if (!out)	return 0;
   \                     ??print_object_6: (+1)
   \   00000074   0x2E00             CMP      R6,#+0
   \   00000076   0xD101             BNE.N    ??print_object_9
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0xE224             B.N      ??print_object_10
    822                  ptr = out;
   \                     ??print_object_9: (+1)
   \   0000007C   0x46B2             MOV      R10,R6
    823                  *ptr++ = '{';
   \   0000007E   0x207B             MOVS     R0,#+123
   \   00000080   0xF88A 0x0000      STRB     R0,[R10, #+0]
   \   00000084   0xF11A 0x0A01      ADDS     R10,R10,#+1
    824                  if (fmt)
   \   00000088   0x2D00             CMP      R5,#+0
   \   0000008A   0xD011             BEQ.N    ??print_object_11
    825                  {
    826                      *ptr++ = '\n';
   \   0000008C   0x200A             MOVS     R0,#+10
   \   0000008E   0xF88A 0x0000      STRB     R0,[R10, #+0]
   \   00000092   0xF11A 0x0A01      ADDS     R10,R10,#+1
    827                      for (i = 0; i < depth - 1; i++) *ptr++ = '\t';
   \   00000096   0xF05F 0x0800      MOVS     R8,#+0
   \   0000009A   0xE006             B.N      ??print_object_12
   \                     ??print_object_13: (+1)
   \   0000009C   0x2009             MOVS     R0,#+9
   \   0000009E   0xF88A 0x0000      STRB     R0,[R10, #+0]
   \   000000A2   0xF11A 0x0A01      ADDS     R10,R10,#+1
   \   000000A6   0xF118 0x0801      ADDS     R8,R8,#+1
   \                     ??print_object_12: (+1)
   \   000000AA   0x1E60             SUBS     R0,R4,#+1
   \   000000AC   0x4580             CMP      R8,R0
   \   000000AE   0xDBF5             BLT.N    ??print_object_13
    828                  }
    829                  *ptr++ = '}';
   \                     ??print_object_11: (+1)
   \   000000B0   0x207D             MOVS     R0,#+125
   \   000000B2   0xF88A 0x0000      STRB     R0,[R10, #+0]
   \   000000B6   0xF11A 0x0A01      ADDS     R10,R10,#+1
    830                  *ptr++ = 0;
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0xF88A 0x0000      STRB     R0,[R10, #+0]
   \   000000C0   0xF11A 0x0A01      ADDS     R10,R10,#+1
    831                  return out;
   \   000000C4   0x0030             MOVS     R0,R6
   \   000000C6   0xE1FE             B.N      ??print_object_10
    832              }
    833              if (p)
   \                     ??print_object_2: (+1)
   \   000000C8   0xF1BB 0x0F00      CMP      R11,#+0
   \   000000CC   0xF000 0x80D9      BEQ.W    ??print_object_14
    834              {
    835                  /* Compose the output: */
    836                  i = p->offset;
   \   000000D0   0xF8DB 0x8008      LDR      R8,[R11, #+8]
    837                  len = fmt ? 2 : 1;
   \   000000D4   0x2D00             CMP      R5,#+0
   \   000000D6   0xD001             BEQ.N    ??print_object_15
   \   000000D8   0x2702             MOVS     R7,#+2
   \   000000DA   0xE000             B.N      ??print_object_16
   \                     ??print_object_15: (+1)
   \   000000DC   0x2701             MOVS     R7,#+1
    838                  ptr = ensure(p, len + 1);
   \                     ??print_object_16: (+1)
   \   000000DE   0x1C79             ADDS     R1,R7,#+1
   \   000000E0   0x4658             MOV      R0,R11
   \   000000E2   0x.... 0x....      BL       ensure
   \   000000E6   0x4682             MOV      R10,R0
    839                  if (!ptr) return 0;
   \   000000E8   0xF1BA 0x0F00      CMP      R10,#+0
   \   000000EC   0xD101             BNE.N    ??print_object_17
   \   000000EE   0x2000             MOVS     R0,#+0
   \   000000F0   0xE1E9             B.N      ??print_object_10
    840                  *ptr++ = '{';
   \                     ??print_object_17: (+1)
   \   000000F2   0x207B             MOVS     R0,#+123
   \   000000F4   0xF88A 0x0000      STRB     R0,[R10, #+0]
   \   000000F8   0xF11A 0x0A01      ADDS     R10,R10,#+1
    841                  if (fmt) *ptr++ = '\n';
   \   000000FC   0x2D00             CMP      R5,#+0
   \   000000FE   0xD004             BEQ.N    ??print_object_18
   \   00000100   0x200A             MOVS     R0,#+10
   \   00000102   0xF88A 0x0000      STRB     R0,[R10, #+0]
   \   00000106   0xF11A 0x0A01      ADDS     R10,R10,#+1
    842                  *ptr = 0;
   \                     ??print_object_18: (+1)
   \   0000010A   0x2000             MOVS     R0,#+0
   \   0000010C   0xF88A 0x0000      STRB     R0,[R10, #+0]
    843                  p->offset += len;
   \   00000110   0xF8DB 0x0008      LDR      R0,[R11, #+8]
   \   00000114   0x1838             ADDS     R0,R7,R0
   \   00000116   0xF8CB 0x0008      STR      R0,[R11, #+8]
    844                  child = item->child;
   \   0000011A   0x9806             LDR      R0,[SP, #+24]
   \   0000011C   0xF8D0 0x9008      LDR      R9,[R0, #+8]
    845                  depth++;
   \   00000120   0x1C64             ADDS     R4,R4,#+1
   \   00000122   0xE019             B.N      ??print_object_19
    846                  while (child)
    847                  {
    848                      if (fmt)
    849                      {
    850                          ptr = ensure(p, depth);
    851                          if (!ptr) return 0;
    852                          for (j = 0; j < depth; j++) *ptr++ = '\t';
    853                          p->offset += depth;
    854                      }
    855                      print_string_ptr(child->string, p);
    856                      p->offset = update(p);
    857          
    858                      len = fmt ? 2 : 1;
    859                      ptr = ensure(p, len);
    860                      if (!ptr) return 0;
    861                      *ptr++ = ':';
    862                      if (fmt) *ptr++ = '\t';
    863                      p->offset += len;
    864          
    865                      print_value(child, depth, fmt, p);
    866                      p->offset = update(p);
    867          
    868                      len = (fmt ? 1 : 0) + (child->next ? 1 : 0);
    869                      ptr = ensure(p, len + 1);
    870                      if (!ptr) return 0;
    871                      if (child->next) *ptr++ = ',';
   \                     ??print_object_20: (+1)
   \   00000124   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \   00000128   0x2800             CMP      R0,#+0
   \   0000012A   0xD004             BEQ.N    ??print_object_21
   \   0000012C   0x202C             MOVS     R0,#+44
   \   0000012E   0xF88A 0x0000      STRB     R0,[R10, #+0]
   \   00000132   0xF11A 0x0A01      ADDS     R10,R10,#+1
    872                      if (fmt) *ptr++ = '\n';
   \                     ??print_object_21: (+1)
   \   00000136   0x2D00             CMP      R5,#+0
   \   00000138   0xD004             BEQ.N    ??print_object_22
   \   0000013A   0x200A             MOVS     R0,#+10
   \   0000013C   0xF88A 0x0000      STRB     R0,[R10, #+0]
   \   00000140   0xF11A 0x0A01      ADDS     R10,R10,#+1
    873                      *ptr = 0;
   \                     ??print_object_22: (+1)
   \   00000144   0x2000             MOVS     R0,#+0
   \   00000146   0xF88A 0x0000      STRB     R0,[R10, #+0]
    874                      p->offset += len;
   \   0000014A   0xF8DB 0x0008      LDR      R0,[R11, #+8]
   \   0000014E   0x1838             ADDS     R0,R7,R0
   \   00000150   0xF8CB 0x0008      STR      R0,[R11, #+8]
    875                      child = child->next;
   \   00000154   0xF8D9 0x9000      LDR      R9,[R9, #+0]
   \                     ??print_object_19: (+1)
   \   00000158   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000015C   0xD067             BEQ.N    ??print_object_23
   \   0000015E   0x2D00             CMP      R5,#+0
   \   00000160   0xD018             BEQ.N    ??print_object_24
   \   00000162   0x0021             MOVS     R1,R4
   \   00000164   0x4658             MOV      R0,R11
   \   00000166   0x.... 0x....      BL       ensure
   \   0000016A   0x4682             MOV      R10,R0
   \   0000016C   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000170   0xD101             BNE.N    ??print_object_25
   \   00000172   0x2000             MOVS     R0,#+0
   \   00000174   0xE1A7             B.N      ??print_object_10
   \                     ??print_object_25: (+1)
   \   00000176   0x2000             MOVS     R0,#+0
   \   00000178   0xE005             B.N      ??print_object_26
   \                     ??print_object_27: (+1)
   \   0000017A   0x2109             MOVS     R1,#+9
   \   0000017C   0xF88A 0x1000      STRB     R1,[R10, #+0]
   \   00000180   0xF11A 0x0A01      ADDS     R10,R10,#+1
   \   00000184   0x1C40             ADDS     R0,R0,#+1
   \                     ??print_object_26: (+1)
   \   00000186   0x42A0             CMP      R0,R4
   \   00000188   0xDBF7             BLT.N    ??print_object_27
   \   0000018A   0xF8DB 0x0008      LDR      R0,[R11, #+8]
   \   0000018E   0x1820             ADDS     R0,R4,R0
   \   00000190   0xF8CB 0x0008      STR      R0,[R11, #+8]
   \                     ??print_object_24: (+1)
   \   00000194   0x4659             MOV      R1,R11
   \   00000196   0xF8D9 0x0020      LDR      R0,[R9, #+32]
   \   0000019A   0x.... 0x....      BL       print_string_ptr
   \   0000019E   0x4658             MOV      R0,R11
   \   000001A0   0x.... 0x....      BL       update
   \   000001A4   0xF8CB 0x0008      STR      R0,[R11, #+8]
   \   000001A8   0x2D00             CMP      R5,#+0
   \   000001AA   0xD001             BEQ.N    ??print_object_28
   \   000001AC   0x2702             MOVS     R7,#+2
   \   000001AE   0xE000             B.N      ??print_object_29
   \                     ??print_object_28: (+1)
   \   000001B0   0x2701             MOVS     R7,#+1
   \                     ??print_object_29: (+1)
   \   000001B2   0x0039             MOVS     R1,R7
   \   000001B4   0x4658             MOV      R0,R11
   \   000001B6   0x.... 0x....      BL       ensure
   \   000001BA   0x4682             MOV      R10,R0
   \   000001BC   0xF1BA 0x0F00      CMP      R10,#+0
   \   000001C0   0xD101             BNE.N    ??print_object_30
   \   000001C2   0x2000             MOVS     R0,#+0
   \   000001C4   0xE17F             B.N      ??print_object_10
   \                     ??print_object_30: (+1)
   \   000001C6   0x203A             MOVS     R0,#+58
   \   000001C8   0xF88A 0x0000      STRB     R0,[R10, #+0]
   \   000001CC   0xF11A 0x0A01      ADDS     R10,R10,#+1
   \   000001D0   0x2D00             CMP      R5,#+0
   \   000001D2   0xD004             BEQ.N    ??print_object_31
   \   000001D4   0x2009             MOVS     R0,#+9
   \   000001D6   0xF88A 0x0000      STRB     R0,[R10, #+0]
   \   000001DA   0xF11A 0x0A01      ADDS     R10,R10,#+1
   \                     ??print_object_31: (+1)
   \   000001DE   0xF8DB 0x0008      LDR      R0,[R11, #+8]
   \   000001E2   0x1838             ADDS     R0,R7,R0
   \   000001E4   0xF8CB 0x0008      STR      R0,[R11, #+8]
   \   000001E8   0x465B             MOV      R3,R11
   \   000001EA   0x002A             MOVS     R2,R5
   \   000001EC   0x0021             MOVS     R1,R4
   \   000001EE   0x4648             MOV      R0,R9
   \   000001F0   0x.... 0x....      BL       print_value
   \   000001F4   0x4658             MOV      R0,R11
   \   000001F6   0x.... 0x....      BL       update
   \   000001FA   0xF8CB 0x0008      STR      R0,[R11, #+8]
   \   000001FE   0x2D00             CMP      R5,#+0
   \   00000200   0xD001             BEQ.N    ??print_object_32
   \   00000202   0x2001             MOVS     R0,#+1
   \   00000204   0xE000             B.N      ??print_object_33
   \                     ??print_object_32: (+1)
   \   00000206   0x2000             MOVS     R0,#+0
   \                     ??print_object_33: (+1)
   \   00000208   0xF8D9 0x1000      LDR      R1,[R9, #+0]
   \   0000020C   0x2900             CMP      R1,#+0
   \   0000020E   0xD001             BEQ.N    ??print_object_34
   \   00000210   0x2101             MOVS     R1,#+1
   \   00000212   0xE000             B.N      ??print_object_35
   \                     ??print_object_34: (+1)
   \   00000214   0x2100             MOVS     R1,#+0
   \                     ??print_object_35: (+1)
   \   00000216   0x180F             ADDS     R7,R1,R0
   \   00000218   0x1C79             ADDS     R1,R7,#+1
   \   0000021A   0x4658             MOV      R0,R11
   \   0000021C   0x.... 0x....      BL       ensure
   \   00000220   0x4682             MOV      R10,R0
   \   00000222   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000226   0xF47F 0xAF7D      BNE.W    ??print_object_20
   \   0000022A   0x2000             MOVS     R0,#+0
   \   0000022C   0xE14B             B.N      ??print_object_10
    876                  }
    877                  ptr = ensure(p, fmt ? (depth + 1) : 2);
   \                     ??print_object_23: (+1)
   \   0000022E   0x2D00             CMP      R5,#+0
   \   00000230   0xD001             BEQ.N    ??print_object_36
   \   00000232   0x1C61             ADDS     R1,R4,#+1
   \   00000234   0xE000             B.N      ??print_object_37
   \                     ??print_object_36: (+1)
   \   00000236   0x2102             MOVS     R1,#+2
   \                     ??print_object_37: (+1)
   \   00000238   0x4658             MOV      R0,R11
   \   0000023A   0x.... 0x....      BL       ensure
   \   0000023E   0x4682             MOV      R10,R0
    878                  if (!ptr) return 0;
   \   00000240   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000244   0xD101             BNE.N    ??print_object_38
   \   00000246   0x2000             MOVS     R0,#+0
   \   00000248   0xE13D             B.N      ??print_object_10
    879                  if (fmt)	for (i = 0; i < depth - 1; i++) *ptr++ = '\t';
   \                     ??print_object_38: (+1)
   \   0000024A   0x2D00             CMP      R5,#+0
   \   0000024C   0xD00C             BEQ.N    ??print_object_39
   \   0000024E   0xF05F 0x0800      MOVS     R8,#+0
   \   00000252   0xE006             B.N      ??print_object_40
   \                     ??print_object_41: (+1)
   \   00000254   0x2009             MOVS     R0,#+9
   \   00000256   0xF88A 0x0000      STRB     R0,[R10, #+0]
   \   0000025A   0xF11A 0x0A01      ADDS     R10,R10,#+1
   \   0000025E   0xF118 0x0801      ADDS     R8,R8,#+1
   \                     ??print_object_40: (+1)
   \   00000262   0x1E60             SUBS     R0,R4,#+1
   \   00000264   0x4580             CMP      R8,R0
   \   00000266   0xDBF5             BLT.N    ??print_object_41
    880                  *ptr++ = '}';
   \                     ??print_object_39: (+1)
   \   00000268   0x207D             MOVS     R0,#+125
   \   0000026A   0xF88A 0x0000      STRB     R0,[R10, #+0]
   \   0000026E   0xF11A 0x0A01      ADDS     R10,R10,#+1
    881                  *ptr = 0;
   \   00000272   0x2000             MOVS     R0,#+0
   \   00000274   0xF88A 0x0000      STRB     R0,[R10, #+0]
    882                  out = (p->buffer) + i;
   \   00000278   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \   0000027C   0xEB18 0x0600      ADDS     R6,R8,R0
   \   00000280   0xE120             B.N      ??print_object_42
    883              }
    884              else
    885              {
    886                  /* Allocate space for the names and the objects */
    887                  entries = (char **)cJSON_malloc(numentries * sizeof(char *));
   \                     ??print_object_14: (+1)
   \   00000282   0x9802             LDR      R0,[SP, #+8]
   \   00000284   0x0080             LSLS     R0,R0,#+2
   \   00000286   0x....             LDR.N    R1,??DataTable19_1
   \   00000288   0x6809             LDR      R1,[R1, #+0]
   \   0000028A   0x4788             BLX      R1
   \   0000028C   0x9000             STR      R0,[SP, #+0]
    888                  if (!entries) return 0;
   \   0000028E   0x9800             LDR      R0,[SP, #+0]
   \   00000290   0x2800             CMP      R0,#+0
   \   00000292   0xD101             BNE.N    ??print_object_43
   \   00000294   0x2000             MOVS     R0,#+0
   \   00000296   0xE116             B.N      ??print_object_10
    889                  names = (char **)cJSON_malloc(numentries * sizeof(char *));
   \                     ??print_object_43: (+1)
   \   00000298   0x9802             LDR      R0,[SP, #+8]
   \   0000029A   0x0080             LSLS     R0,R0,#+2
   \   0000029C   0x....             LDR.N    R1,??DataTable19_1
   \   0000029E   0x6809             LDR      R1,[R1, #+0]
   \   000002A0   0x4788             BLX      R1
   \   000002A2   0x9001             STR      R0,[SP, #+4]
    890                  if (!names)
   \   000002A4   0x9801             LDR      R0,[SP, #+4]
   \   000002A6   0x2800             CMP      R0,#+0
   \   000002A8   0xD105             BNE.N    ??print_object_44
    891                  {
    892                      cJSON_free(entries);
   \   000002AA   0x9800             LDR      R0,[SP, #+0]
   \   000002AC   0x....             LDR.N    R1,??DataTable19_5
   \   000002AE   0x6809             LDR      R1,[R1, #+0]
   \   000002B0   0x4788             BLX      R1
    893                      return 0;
   \   000002B2   0x2000             MOVS     R0,#+0
   \   000002B4   0xE107             B.N      ??print_object_10
    894                  }
    895                  memset(entries, 0, sizeof(char *)*numentries);
   \                     ??print_object_44: (+1)
   \   000002B6   0x9802             LDR      R0,[SP, #+8]
   \   000002B8   0x0082             LSLS     R2,R0,#+2
   \   000002BA   0x2100             MOVS     R1,#+0
   \   000002BC   0x9800             LDR      R0,[SP, #+0]
   \   000002BE   0x.... 0x....      BL       memset
    896                  memset(names, 0, sizeof(char *)*numentries);
   \   000002C2   0x9802             LDR      R0,[SP, #+8]
   \   000002C4   0x0082             LSLS     R2,R0,#+2
   \   000002C6   0x2100             MOVS     R1,#+0
   \   000002C8   0x9801             LDR      R0,[SP, #+4]
   \   000002CA   0x.... 0x....      BL       memset
    897          
    898                  /* Collect all the results into our arrays: */
    899                  child = item->child;
   \   000002CE   0x9806             LDR      R0,[SP, #+24]
   \   000002D0   0xF8D0 0x9008      LDR      R9,[R0, #+8]
    900                  depth++;
   \   000002D4   0x1C64             ADDS     R4,R4,#+1
    901                  if (fmt) len += depth;
   \   000002D6   0x2D00             CMP      R5,#+0
   \   000002D8   0xD005             BEQ.N    ??print_object_45
   \   000002DA   0x19E7             ADDS     R7,R4,R7
   \   000002DC   0xE003             B.N      ??print_object_45
    902                  while (child)
    903                  {
    904                      names[i] = str = print_string_ptr(child->string, 0);
    905                      entries[i++] = ret = print_value(child, depth, fmt, 0);
    906                      if (str && ret) len += strlen(ret) + strlen(str) + 2 + (fmt ? 2 + depth : 0);
    907                      else fail = 1;
   \                     ??print_object_46: (+1)
   \   000002DE   0xF05F 0x0A01      MOVS     R10,#+1
    908                      child = child->next;
   \                     ??print_object_47: (+1)
   \   000002E2   0xF8D9 0x9000      LDR      R9,[R9, #+0]
   \                     ??print_object_45: (+1)
   \   000002E6   0xF1B9 0x0F00      CMP      R9,#+0
   \   000002EA   0xD029             BEQ.N    ??print_object_48
   \   000002EC   0x2100             MOVS     R1,#+0
   \   000002EE   0xF8D9 0x0020      LDR      R0,[R9, #+32]
   \   000002F2   0x.... 0x....      BL       print_string_ptr
   \   000002F6   0x9004             STR      R0,[SP, #+16]
   \   000002F8   0x9901             LDR      R1,[SP, #+4]
   \   000002FA   0xF841 0x0028      STR      R0,[R1, R8, LSL #+2]
   \   000002FE   0x2300             MOVS     R3,#+0
   \   00000300   0x002A             MOVS     R2,R5
   \   00000302   0x0021             MOVS     R1,R4
   \   00000304   0x4648             MOV      R0,R9
   \   00000306   0x.... 0x....      BL       print_value
   \   0000030A   0x9900             LDR      R1,[SP, #+0]
   \   0000030C   0xF841 0x0028      STR      R0,[R1, R8, LSL #+2]
   \   00000310   0xF118 0x0801      ADDS     R8,R8,#+1
   \   00000314   0x9904             LDR      R1,[SP, #+16]
   \   00000316   0x2900             CMP      R1,#+0
   \   00000318   0xD0E1             BEQ.N    ??print_object_46
   \   0000031A   0x2800             CMP      R0,#+0
   \   0000031C   0xD0DF             BEQ.N    ??print_object_46
   \   0000031E   0x.... 0x....      BL       strlen
   \   00000322   0x4683             MOV      R11,R0
   \   00000324   0x9804             LDR      R0,[SP, #+16]
   \   00000326   0x.... 0x....      BL       strlen
   \   0000032A   0x2D00             CMP      R5,#+0
   \   0000032C   0xD001             BEQ.N    ??print_object_49
   \   0000032E   0x1CA1             ADDS     R1,R4,#+2
   \   00000330   0xE000             B.N      ??print_object_50
   \                     ??print_object_49: (+1)
   \   00000332   0x2100             MOVS     R1,#+0
   \                     ??print_object_50: (+1)
   \   00000334   0xEB10 0x000B      ADDS     R0,R0,R11
   \   00000338   0x1808             ADDS     R0,R1,R0
   \   0000033A   0x1C80             ADDS     R0,R0,#+2
   \   0000033C   0x19C7             ADDS     R7,R0,R7
   \   0000033E   0xE7D0             B.N      ??print_object_47
    909                  }
    910          
    911                  /* Try to allocate the output string */
    912                  if (!fail)	out = (char *)cJSON_malloc(len);
   \                     ??print_object_48: (+1)
   \   00000340   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000344   0xD104             BNE.N    ??print_object_51
   \   00000346   0x0038             MOVS     R0,R7
   \   00000348   0x....             LDR.N    R1,??DataTable19_1
   \   0000034A   0x6809             LDR      R1,[R1, #+0]
   \   0000034C   0x4788             BLX      R1
   \   0000034E   0x0006             MOVS     R6,R0
    913                  if (!out) fail = 1;
   \                     ??print_object_51: (+1)
   \   00000350   0x2E00             CMP      R6,#+0
   \   00000352   0xD101             BNE.N    ??print_object_52
   \   00000354   0xF05F 0x0A01      MOVS     R10,#+1
    914          
    915                  /* Handle failure */
    916                  if (fail)
   \                     ??print_object_52: (+1)
   \   00000358   0xF1BA 0x0F00      CMP      R10,#+0
   \   0000035C   0xD027             BEQ.N    ??print_object_53
    917                  {
    918                      for (i = 0; i < numentries; i++)
   \   0000035E   0xF05F 0x0800      MOVS     R8,#+0
   \   00000362   0xE017             B.N      ??print_object_54
    919                      {
    920                          if (names[i]) cJSON_free(names[i]);
   \                     ??print_object_55: (+1)
   \   00000364   0x9801             LDR      R0,[SP, #+4]
   \   00000366   0xF850 0x0028      LDR      R0,[R0, R8, LSL #+2]
   \   0000036A   0x2800             CMP      R0,#+0
   \   0000036C   0xD005             BEQ.N    ??print_object_56
   \   0000036E   0x9801             LDR      R0,[SP, #+4]
   \   00000370   0xF850 0x0028      LDR      R0,[R0, R8, LSL #+2]
   \   00000374   0x....             LDR.N    R1,??DataTable19_5
   \   00000376   0x6809             LDR      R1,[R1, #+0]
   \   00000378   0x4788             BLX      R1
    921                          if (entries[i]) cJSON_free(entries[i]);
   \                     ??print_object_56: (+1)
   \   0000037A   0x9800             LDR      R0,[SP, #+0]
   \   0000037C   0xF850 0x0028      LDR      R0,[R0, R8, LSL #+2]
   \   00000380   0x2800             CMP      R0,#+0
   \   00000382   0xD005             BEQ.N    ??print_object_57
   \   00000384   0x9800             LDR      R0,[SP, #+0]
   \   00000386   0xF850 0x0028      LDR      R0,[R0, R8, LSL #+2]
   \   0000038A   0x....             LDR.N    R1,??DataTable19_5
   \   0000038C   0x6809             LDR      R1,[R1, #+0]
   \   0000038E   0x4788             BLX      R1
    922                      }
   \                     ??print_object_57: (+1)
   \   00000390   0xF118 0x0801      ADDS     R8,R8,#+1
   \                     ??print_object_54: (+1)
   \   00000394   0x9802             LDR      R0,[SP, #+8]
   \   00000396   0x4580             CMP      R8,R0
   \   00000398   0xDBE4             BLT.N    ??print_object_55
    923                      cJSON_free(names);
   \   0000039A   0x9801             LDR      R0,[SP, #+4]
   \   0000039C   0x....             LDR.N    R1,??DataTable19_5
   \   0000039E   0x6809             LDR      R1,[R1, #+0]
   \   000003A0   0x4788             BLX      R1
    924                      cJSON_free(entries);
   \   000003A2   0x9800             LDR      R0,[SP, #+0]
   \   000003A4   0x....             LDR.N    R1,??DataTable19_5
   \   000003A6   0x6809             LDR      R1,[R1, #+0]
   \   000003A8   0x4788             BLX      R1
    925                      return 0;
   \   000003AA   0x2000             MOVS     R0,#+0
   \   000003AC   0xE08B             B.N      ??print_object_10
    926                  }
    927          
    928                  /* Compose the output: */
    929                  *out = '{';
   \                     ??print_object_53: (+1)
   \   000003AE   0x207B             MOVS     R0,#+123
   \   000003B0   0x7030             STRB     R0,[R6, #+0]
    930                  ptr = out + 1;
   \   000003B2   0xF116 0x0A01      ADDS     R10,R6,#+1
    931                  if (fmt)*ptr++ = '\n';
   \   000003B6   0x2D00             CMP      R5,#+0
   \   000003B8   0xD004             BEQ.N    ??print_object_58
   \   000003BA   0x200A             MOVS     R0,#+10
   \   000003BC   0xF88A 0x0000      STRB     R0,[R10, #+0]
   \   000003C0   0xF11A 0x0A01      ADDS     R10,R10,#+1
    932                  *ptr = 0;
   \                     ??print_object_58: (+1)
   \   000003C4   0x2000             MOVS     R0,#+0
   \   000003C6   0xF88A 0x0000      STRB     R0,[R10, #+0]
    933                  for (i = 0; i < numentries; i++)
   \   000003CA   0xF05F 0x0800      MOVS     R8,#+0
   \   000003CE   0xE051             B.N      ??print_object_59
    934                  {
    935                      if (fmt) for (j = 0; j < depth; j++) *ptr++ = '\t';
   \                     ??print_object_60: (+1)
   \   000003D0   0x2109             MOVS     R1,#+9
   \   000003D2   0xF88A 0x1000      STRB     R1,[R10, #+0]
   \   000003D6   0xF11A 0x0A01      ADDS     R10,R10,#+1
   \   000003DA   0x1C40             ADDS     R0,R0,#+1
   \                     ??print_object_61: (+1)
   \   000003DC   0x42A0             CMP      R0,R4
   \   000003DE   0xDBF7             BLT.N    ??print_object_60
    936                      tmplen = strlen(names[i]);
   \                     ??print_object_62: (+1)
   \   000003E0   0x9801             LDR      R0,[SP, #+4]
   \   000003E2   0xF850 0x0028      LDR      R0,[R0, R8, LSL #+2]
   \   000003E6   0x.... 0x....      BL       strlen
   \   000003EA   0x9003             STR      R0,[SP, #+12]
    937                      memcpy(ptr, names[i], tmplen);
   \   000003EC   0x9A03             LDR      R2,[SP, #+12]
   \   000003EE   0x9801             LDR      R0,[SP, #+4]
   \   000003F0   0xF850 0x1028      LDR      R1,[R0, R8, LSL #+2]
   \   000003F4   0x4650             MOV      R0,R10
   \   000003F6   0x.... 0x....      BL       memcpy
    938                      ptr += tmplen;
   \   000003FA   0x9803             LDR      R0,[SP, #+12]
   \   000003FC   0xEB10 0x0A0A      ADDS     R10,R0,R10
    939                      *ptr++ = ':';
   \   00000400   0x203A             MOVS     R0,#+58
   \   00000402   0xF88A 0x0000      STRB     R0,[R10, #+0]
   \   00000406   0xF11A 0x0A01      ADDS     R10,R10,#+1
    940                      if (fmt) *ptr++ = '\t';
   \   0000040A   0x2D00             CMP      R5,#+0
   \   0000040C   0xD004             BEQ.N    ??print_object_63
   \   0000040E   0x2009             MOVS     R0,#+9
   \   00000410   0xF88A 0x0000      STRB     R0,[R10, #+0]
   \   00000414   0xF11A 0x0A01      ADDS     R10,R10,#+1
    941                      strcpy(ptr, entries[i]);
   \                     ??print_object_63: (+1)
   \   00000418   0x9800             LDR      R0,[SP, #+0]
   \   0000041A   0xF850 0x1028      LDR      R1,[R0, R8, LSL #+2]
   \   0000041E   0x4650             MOV      R0,R10
   \   00000420   0x.... 0x....      BL       strcpy
    942                      ptr += strlen(entries[i]);
   \   00000424   0x9800             LDR      R0,[SP, #+0]
   \   00000426   0xF850 0x0028      LDR      R0,[R0, R8, LSL #+2]
   \   0000042A   0x.... 0x....      BL       strlen
   \   0000042E   0xEB10 0x0A0A      ADDS     R10,R0,R10
    943                      if (i != numentries - 1) *ptr++ = ',';
   \   00000432   0x9802             LDR      R0,[SP, #+8]
   \   00000434   0x1E40             SUBS     R0,R0,#+1
   \   00000436   0x4580             CMP      R8,R0
   \   00000438   0xD004             BEQ.N    ??print_object_64
   \   0000043A   0x202C             MOVS     R0,#+44
   \   0000043C   0xF88A 0x0000      STRB     R0,[R10, #+0]
   \   00000440   0xF11A 0x0A01      ADDS     R10,R10,#+1
    944                      if (fmt) *ptr++ = '\n';
   \                     ??print_object_64: (+1)
   \   00000444   0x2D00             CMP      R5,#+0
   \   00000446   0xD004             BEQ.N    ??print_object_65
   \   00000448   0x200A             MOVS     R0,#+10
   \   0000044A   0xF88A 0x0000      STRB     R0,[R10, #+0]
   \   0000044E   0xF11A 0x0A01      ADDS     R10,R10,#+1
    945                      *ptr = 0;
   \                     ??print_object_65: (+1)
   \   00000452   0x2000             MOVS     R0,#+0
   \   00000454   0xF88A 0x0000      STRB     R0,[R10, #+0]
    946                      cJSON_free(names[i]);
   \   00000458   0x9801             LDR      R0,[SP, #+4]
   \   0000045A   0xF850 0x0028      LDR      R0,[R0, R8, LSL #+2]
   \   0000045E   0x....             LDR.N    R1,??DataTable19_5
   \   00000460   0x6809             LDR      R1,[R1, #+0]
   \   00000462   0x4788             BLX      R1
    947                      cJSON_free(entries[i]);
   \   00000464   0x9800             LDR      R0,[SP, #+0]
   \   00000466   0xF850 0x0028      LDR      R0,[R0, R8, LSL #+2]
   \   0000046A   0x....             LDR.N    R1,??DataTable19_5
   \   0000046C   0x6809             LDR      R1,[R1, #+0]
   \   0000046E   0x4788             BLX      R1
   \   00000470   0xF118 0x0801      ADDS     R8,R8,#+1
   \                     ??print_object_59: (+1)
   \   00000474   0x9802             LDR      R0,[SP, #+8]
   \   00000476   0x4580             CMP      R8,R0
   \   00000478   0xDA03             BGE.N    ??print_object_66
   \   0000047A   0x2D00             CMP      R5,#+0
   \   0000047C   0xD0B0             BEQ.N    ??print_object_62
   \   0000047E   0x2000             MOVS     R0,#+0
   \   00000480   0xE7AC             B.N      ??print_object_61
    948                  }
    949          
    950                  cJSON_free(names);
   \                     ??print_object_66: (+1)
   \   00000482   0x9801             LDR      R0,[SP, #+4]
   \   00000484   0x....             LDR.N    R1,??DataTable19_5
   \   00000486   0x6809             LDR      R1,[R1, #+0]
   \   00000488   0x4788             BLX      R1
    951                  cJSON_free(entries);
   \   0000048A   0x9800             LDR      R0,[SP, #+0]
   \   0000048C   0x....             LDR.N    R1,??DataTable19_5
   \   0000048E   0x6809             LDR      R1,[R1, #+0]
   \   00000490   0x4788             BLX      R1
    952                  if (fmt) for (i = 0; i < depth - 1; i++) *ptr++ = '\t';
   \   00000492   0x2D00             CMP      R5,#+0
   \   00000494   0xD00C             BEQ.N    ??print_object_67
   \   00000496   0xF05F 0x0800      MOVS     R8,#+0
   \   0000049A   0xE006             B.N      ??print_object_68
   \                     ??print_object_69: (+1)
   \   0000049C   0x2009             MOVS     R0,#+9
   \   0000049E   0xF88A 0x0000      STRB     R0,[R10, #+0]
   \   000004A2   0xF11A 0x0A01      ADDS     R10,R10,#+1
   \   000004A6   0xF118 0x0801      ADDS     R8,R8,#+1
   \                     ??print_object_68: (+1)
   \   000004AA   0x1E60             SUBS     R0,R4,#+1
   \   000004AC   0x4580             CMP      R8,R0
   \   000004AE   0xDBF5             BLT.N    ??print_object_69
    953                  *ptr++ = '}';
   \                     ??print_object_67: (+1)
   \   000004B0   0x207D             MOVS     R0,#+125
   \   000004B2   0xF88A 0x0000      STRB     R0,[R10, #+0]
   \   000004B6   0xF11A 0x0A01      ADDS     R10,R10,#+1
    954                  *ptr++ = 0;
   \   000004BA   0x2000             MOVS     R0,#+0
   \   000004BC   0xF88A 0x0000      STRB     R0,[R10, #+0]
   \   000004C0   0xF11A 0x0A01      ADDS     R10,R10,#+1
    955              }
    956              return out;
   \                     ??print_object_42: (+1)
   \   000004C4   0x0030             MOVS     R0,R6
   \                     ??print_object_10: (+1)
   \   000004C6   0xB007             ADD      SP,SP,#+28
   \   000004C8   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    957          }
    958          
    959          /* Get Array size/item / object item. */

   \                                 In section .text, align 2, keep-with-next
    960          int    cJSON_GetArraySize(cJSON *array)
    961          {
    962              cJSON *c = array->child;
   \                     cJSON_GetArraySize: (+1)
   \   00000000   0x6881             LDR      R1,[R0, #+8]
    963              int i = 0;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0xE001             B.N      ??cJSON_GetArraySize_0
    964              while(c)i++, c = c->next;
   \                     ??cJSON_GetArraySize_1: (+1)
   \   00000006   0x1C40             ADDS     R0,R0,#+1
   \   00000008   0x6809             LDR      R1,[R1, #+0]
   \                     ??cJSON_GetArraySize_0: (+1)
   \   0000000A   0x2900             CMP      R1,#+0
   \   0000000C   0xD1FB             BNE.N    ??cJSON_GetArraySize_1
    965              return i;
   \   0000000E   0x4770             BX       LR               ;; return
    966          }

   \                                 In section .text, align 2, keep-with-next
    967          cJSON *cJSON_GetArrayItem(cJSON *array, int item)
    968          {
    969              cJSON *c = array->child;
   \                     cJSON_GetArrayItem: (+1)
   \   00000000   0x6880             LDR      R0,[R0, #+8]
   \   00000002   0xE001             B.N      ??cJSON_GetArrayItem_0
    970              while (c && item > 0) item--, c = c->next;
   \                     ??cJSON_GetArrayItem_1: (+1)
   \   00000004   0x1E49             SUBS     R1,R1,#+1
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \                     ??cJSON_GetArrayItem_0: (+1)
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD001             BEQ.N    ??cJSON_GetArrayItem_2
   \   0000000C   0x2901             CMP      R1,#+1
   \   0000000E   0xDAF9             BGE.N    ??cJSON_GetArrayItem_1
    971              return c;
   \                     ??cJSON_GetArrayItem_2: (+1)
   \   00000010   0x4770             BX       LR               ;; return
    972          }

   \                                 In section .text, align 2, keep-with-next
    973          cJSON *cJSON_GetObjectItem(cJSON *object, const char *string)
    974          {
   \                     cJSON_GetObjectItem: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x000C             MOVS     R4,R1
    975              cJSON *c = object->child;
   \   00000004   0x6885             LDR      R5,[R0, #+8]
   \   00000006   0xE000             B.N      ??cJSON_GetObjectItem_0
    976              while (c && cJSON_strcasecmp(c->string, string)) c = c->next;
   \                     ??cJSON_GetObjectItem_1: (+1)
   \   00000008   0x682D             LDR      R5,[R5, #+0]
   \                     ??cJSON_GetObjectItem_0: (+1)
   \   0000000A   0x2D00             CMP      R5,#+0
   \   0000000C   0xD005             BEQ.N    ??cJSON_GetObjectItem_2
   \   0000000E   0x0021             MOVS     R1,R4
   \   00000010   0x6A28             LDR      R0,[R5, #+32]
   \   00000012   0x.... 0x....      BL       cJSON_strcasecmp
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD1F6             BNE.N    ??cJSON_GetObjectItem_1
    977              return c;
   \                     ??cJSON_GetObjectItem_2: (+1)
   \   0000001A   0x0028             MOVS     R0,R5
   \   0000001C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    978          }
    979          
    980          /* Utility for array list handling. */

   \                                 In section .text, align 2, keep-with-next
    981          static void suffix_object(cJSON *prev, cJSON *item)
    982          {
    983              prev->next = item;
   \                     suffix_object: (+1)
   \   00000000   0x6001             STR      R1,[R0, #+0]
    984              item->prev = prev;
   \   00000002   0x6048             STR      R0,[R1, #+4]
    985          }
   \   00000004   0x4770             BX       LR               ;; return
    986          /* Utility for handling references. */

   \                                 In section .text, align 2, keep-with-next
    987          static cJSON *create_reference(cJSON *item)
    988          {
   \                     create_reference: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    989              cJSON *ref = cJSON_New_Item();
   \   00000004   0x.... 0x....      BL       cJSON_New_Item
   \   00000008   0x0005             MOVS     R5,R0
    990              if (!ref) return 0;
   \   0000000A   0x2D00             CMP      R5,#+0
   \   0000000C   0xD101             BNE.N    ??create_reference_0
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xE00E             B.N      ??create_reference_1
    991              memcpy(ref, item, sizeof(cJSON));
   \                     ??create_reference_0: (+1)
   \   00000012   0x2228             MOVS     R2,#+40
   \   00000014   0x0021             MOVS     R1,R4
   \   00000016   0x0028             MOVS     R0,R5
   \   00000018   0x.... 0x....      BL       memcpy
    992              ref->string = 0;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x6228             STR      R0,[R5, #+32]
    993              ref->type |= cJSON_IsReference;
   \   00000020   0x68E8             LDR      R0,[R5, #+12]
   \   00000022   0xF450 0x7080      ORRS     R0,R0,#0x100
   \   00000026   0x60E8             STR      R0,[R5, #+12]
    994              ref->next = ref->prev = 0;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x6068             STR      R0,[R5, #+4]
   \   0000002C   0x6028             STR      R0,[R5, #+0]
    995              return ref;
   \   0000002E   0x0028             MOVS     R0,R5
   \                     ??create_reference_1: (+1)
   \   00000030   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    996          }
    997          
    998          /* Add item to array/object. */

   \                                 In section .text, align 2, keep-with-next
    999          void   cJSON_AddItemToArray(cJSON *array, cJSON *item)
   1000          {
   \                     cJSON_AddItemToArray: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1001              cJSON *c = array->child;
   \   00000002   0x6882             LDR      R2,[R0, #+8]
   1002              if (!item) return;
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD00C             BEQ.N    ??cJSON_AddItemToArray_0
   1003              if (!c)
   \                     ??cJSON_AddItemToArray_1: (+1)
   \   00000008   0x2A00             CMP      R2,#+0
   \   0000000A   0xD102             BNE.N    ??cJSON_AddItemToArray_2
   1004              {
   1005                  array->child = item;
   \   0000000C   0x6081             STR      R1,[R0, #+8]
   \   0000000E   0xE008             B.N      ??cJSON_AddItemToArray_3
   1006              }
   1007              else
   1008              {
   1009                  while (c && c->next) c = c->next;
   \                     ??cJSON_AddItemToArray_4: (+1)
   \   00000010   0x6812             LDR      R2,[R2, #+0]
   \                     ??cJSON_AddItemToArray_2: (+1)
   \   00000012   0x2A00             CMP      R2,#+0
   \   00000014   0xD002             BEQ.N    ??cJSON_AddItemToArray_5
   \   00000016   0x6810             LDR      R0,[R2, #+0]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD1F9             BNE.N    ??cJSON_AddItemToArray_4
   1010                  suffix_object(c, item);
   \                     ??cJSON_AddItemToArray_5: (+1)
   \   0000001C   0x0010             MOVS     R0,R2
   \   0000001E   0x.... 0x....      BL       suffix_object
   1011              }
   1012          }
   \                     ??cJSON_AddItemToArray_3: (+1)
   \                     ??cJSON_AddItemToArray_0: (+1)
   \   00000022   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   1013          void   cJSON_AddItemToObject(cJSON *object, const char *string, cJSON *item)
   1014          {
   \                     cJSON_AddItemToObject: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   1015              if (!item) return;
   \   00000008   0x2E00             CMP      R6,#+0
   \   0000000A   0xD00E             BEQ.N    ??cJSON_AddItemToObject_0
   1016              if (item->string) cJSON_free(item->string);
   \                     ??cJSON_AddItemToObject_1: (+1)
   \   0000000C   0x6A30             LDR      R0,[R6, #+32]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD003             BEQ.N    ??cJSON_AddItemToObject_2
   \   00000012   0x6A30             LDR      R0,[R6, #+32]
   \   00000014   0x....             LDR.N    R1,??DataTable19_5
   \   00000016   0x6809             LDR      R1,[R1, #+0]
   \   00000018   0x4788             BLX      R1
   1017              item->string = cJSON_strdup(string);
   \                     ??cJSON_AddItemToObject_2: (+1)
   \   0000001A   0x0028             MOVS     R0,R5
   \   0000001C   0x.... 0x....      BL       cJSON_strdup
   \   00000020   0x6230             STR      R0,[R6, #+32]
   1018              cJSON_AddItemToArray(object, item);
   \   00000022   0x0031             MOVS     R1,R6
   \   00000024   0x0020             MOVS     R0,R4
   \   00000026   0x.... 0x....      BL       cJSON_AddItemToArray
   1019          }
   \                     ??cJSON_AddItemToObject_0: (+1)
   \   0000002A   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   1020          void   cJSON_AddItemToObjectCS(cJSON *object, const char *string, cJSON *item)
   1021          {
   \                     cJSON_AddItemToObjectCS: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000E             MOVS     R6,R1
   \   00000006   0x0015             MOVS     R5,R2
   1022              if (!item) return;
   \   00000008   0x2D00             CMP      R5,#+0
   \   0000000A   0xD012             BEQ.N    ??cJSON_AddItemToObjectCS_0
   1023              if (!(item->type & cJSON_StringIsConst) && item->string) cJSON_free(item->string);
   \                     ??cJSON_AddItemToObjectCS_1: (+1)
   \   0000000C   0x68E8             LDR      R0,[R5, #+12]
   \   0000000E   0x0580             LSLS     R0,R0,#+22
   \   00000010   0xD406             BMI.N    ??cJSON_AddItemToObjectCS_2
   \   00000012   0x6A28             LDR      R0,[R5, #+32]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD003             BEQ.N    ??cJSON_AddItemToObjectCS_2
   \   00000018   0x6A28             LDR      R0,[R5, #+32]
   \   0000001A   0x....             LDR.N    R1,??DataTable19_5
   \   0000001C   0x6809             LDR      R1,[R1, #+0]
   \   0000001E   0x4788             BLX      R1
   1024              item->string = (char *)string;
   \                     ??cJSON_AddItemToObjectCS_2: (+1)
   \   00000020   0x622E             STR      R6,[R5, #+32]
   1025              item->type |= cJSON_StringIsConst;
   \   00000022   0x68E8             LDR      R0,[R5, #+12]
   \   00000024   0xF450 0x7000      ORRS     R0,R0,#0x200
   \   00000028   0x60E8             STR      R0,[R5, #+12]
   1026              cJSON_AddItemToArray(object, item);
   \   0000002A   0x0029             MOVS     R1,R5
   \   0000002C   0x0020             MOVS     R0,R4
   \   0000002E   0x.... 0x....      BL       cJSON_AddItemToArray
   1027          }
   \                     ??cJSON_AddItemToObjectCS_0: (+1)
   \   00000032   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   1028          void	cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item)
   1029          {
   \                     cJSON_AddItemReferenceToArray: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0008             MOVS     R0,R1
   1030              cJSON_AddItemToArray(array, create_reference(item));
   \   00000006   0x.... 0x....      BL       create_reference
   \   0000000A   0x0001             MOVS     R1,R0
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       cJSON_AddItemToArray
   1031          }
   \   00000012   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   1032          void	cJSON_AddItemReferenceToObject(cJSON *object, const char *string, cJSON *item)
   1033          {
   \                     cJSON_AddItemReferenceToObject: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0010             MOVS     R0,R2
   1034              cJSON_AddItemToObject(object, string, create_reference(item));
   \   00000008   0x.... 0x....      BL       create_reference
   \   0000000C   0x0002             MOVS     R2,R0
   \   0000000E   0x0029             MOVS     R1,R5
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0x.... 0x....      BL       cJSON_AddItemToObject
   1035          }
   \   00000016   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1036          

   \                                 In section .text, align 2, keep-with-next
   1037          cJSON *cJSON_DetachItemFromArray(cJSON *array, int which)
   1038          {
   1039              cJSON *c = array->child;
   \                     cJSON_DetachItemFromArray: (+1)
   \   00000000   0x6882             LDR      R2,[R0, #+8]
   \   00000002   0xE001             B.N      ??cJSON_DetachItemFromArray_0
   1040              while (c && which > 0) c = c->next, which--;
   \                     ??cJSON_DetachItemFromArray_1: (+1)
   \   00000004   0x6812             LDR      R2,[R2, #+0]
   \   00000006   0x1E49             SUBS     R1,R1,#+1
   \                     ??cJSON_DetachItemFromArray_0: (+1)
   \   00000008   0x2A00             CMP      R2,#+0
   \   0000000A   0xD001             BEQ.N    ??cJSON_DetachItemFromArray_2
   \   0000000C   0x2901             CMP      R1,#+1
   \   0000000E   0xDAF9             BGE.N    ??cJSON_DetachItemFromArray_1
   1041              if (!c) return 0;
   \                     ??cJSON_DetachItemFromArray_2: (+1)
   \   00000010   0x2A00             CMP      R2,#+0
   \   00000012   0xD101             BNE.N    ??cJSON_DetachItemFromArray_3
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xE014             B.N      ??cJSON_DetachItemFromArray_4
   1042              if (c->prev) c->prev->next = c->next;
   \                     ??cJSON_DetachItemFromArray_3: (+1)
   \   00000018   0x6851             LDR      R1,[R2, #+4]
   \   0000001A   0x2900             CMP      R1,#+0
   \   0000001C   0xD002             BEQ.N    ??cJSON_DetachItemFromArray_5
   \   0000001E   0x6811             LDR      R1,[R2, #+0]
   \   00000020   0x6853             LDR      R3,[R2, #+4]
   \   00000022   0x6019             STR      R1,[R3, #+0]
   1043              if (c->next) c->next->prev = c->prev;
   \                     ??cJSON_DetachItemFromArray_5: (+1)
   \   00000024   0x6811             LDR      R1,[R2, #+0]
   \   00000026   0x2900             CMP      R1,#+0
   \   00000028   0xD002             BEQ.N    ??cJSON_DetachItemFromArray_6
   \   0000002A   0x6851             LDR      R1,[R2, #+4]
   \   0000002C   0x6813             LDR      R3,[R2, #+0]
   \   0000002E   0x6059             STR      R1,[R3, #+4]
   1044              if (c == array->child) array->child = c->next;
   \                     ??cJSON_DetachItemFromArray_6: (+1)
   \   00000030   0x6881             LDR      R1,[R0, #+8]
   \   00000032   0x428A             CMP      R2,R1
   \   00000034   0xD101             BNE.N    ??cJSON_DetachItemFromArray_7
   \   00000036   0x6811             LDR      R1,[R2, #+0]
   \   00000038   0x6081             STR      R1,[R0, #+8]
   1045              c->prev = c->next = 0;
   \                     ??cJSON_DetachItemFromArray_7: (+1)
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x6010             STR      R0,[R2, #+0]
   \   0000003E   0x6050             STR      R0,[R2, #+4]
   1046              return c;
   \   00000040   0x0010             MOVS     R0,R2
   \                     ??cJSON_DetachItemFromArray_4: (+1)
   \   00000042   0x4770             BX       LR               ;; return
   1047          }

   \                                 In section .text, align 2, keep-with-next
   1048          void   cJSON_DeleteItemFromArray(cJSON *array, int which)
   1049          {
   \                     cJSON_DeleteItemFromArray: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1050              cJSON_Delete(cJSON_DetachItemFromArray(array, which));
   \   00000002   0x.... 0x....      BL       cJSON_DetachItemFromArray
   \   00000006   0x.... 0x....      BL       cJSON_Delete
   1051          }
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   1052          cJSON *cJSON_DetachItemFromObject(cJSON *object, const char *string)
   1053          {
   \                     cJSON_DetachItemFromObject: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1054              int i = 0;
   \   00000006   0x2600             MOVS     R6,#+0
   1055              cJSON *c = object->child;
   \   00000008   0x68A7             LDR      R7,[R4, #+8]
   \   0000000A   0xE001             B.N      ??cJSON_DetachItemFromObject_0
   1056              while (c && cJSON_strcasecmp(c->string, string)) i++, c = c->next;
   \                     ??cJSON_DetachItemFromObject_1: (+1)
   \   0000000C   0x1C76             ADDS     R6,R6,#+1
   \   0000000E   0x683F             LDR      R7,[R7, #+0]
   \                     ??cJSON_DetachItemFromObject_0: (+1)
   \   00000010   0x2F00             CMP      R7,#+0
   \   00000012   0xD005             BEQ.N    ??cJSON_DetachItemFromObject_2
   \   00000014   0x0029             MOVS     R1,R5
   \   00000016   0x6A38             LDR      R0,[R7, #+32]
   \   00000018   0x.... 0x....      BL       cJSON_strcasecmp
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD1F5             BNE.N    ??cJSON_DetachItemFromObject_1
   1057              if (c) return cJSON_DetachItemFromArray(object, i);
   \                     ??cJSON_DetachItemFromObject_2: (+1)
   \   00000020   0x2F00             CMP      R7,#+0
   \   00000022   0xD004             BEQ.N    ??cJSON_DetachItemFromObject_3
   \   00000024   0x0031             MOVS     R1,R6
   \   00000026   0x0020             MOVS     R0,R4
   \   00000028   0x.... 0x....      BL       cJSON_DetachItemFromArray
   \   0000002C   0xE000             B.N      ??cJSON_DetachItemFromObject_4
   1058              return 0;
   \                     ??cJSON_DetachItemFromObject_3: (+1)
   \   0000002E   0x2000             MOVS     R0,#+0
   \                     ??cJSON_DetachItemFromObject_4: (+1)
   \   00000030   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1059          }

   \                                 In section .text, align 2, keep-with-next
   1060          void   cJSON_DeleteItemFromObject(cJSON *object, const char *string)
   1061          {
   \                     cJSON_DeleteItemFromObject: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1062              cJSON_Delete(cJSON_DetachItemFromObject(object, string));
   \   00000002   0x.... 0x....      BL       cJSON_DetachItemFromObject
   \   00000006   0x.... 0x....      BL       cJSON_Delete
   1063          }
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return
   1064          
   1065          /* Replace array/object items with new ones. */

   \                                 In section .text, align 2, keep-with-next
   1066          void   cJSON_InsertItemInArray(cJSON *array, int which, cJSON *newitem)
   1067          {
   \                     cJSON_InsertItemInArray: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1068              cJSON *c = array->child;
   \   00000002   0x6883             LDR      R3,[R0, #+8]
   \   00000004   0xE001             B.N      ??cJSON_InsertItemInArray_0
   1069              while (c && which > 0) c = c->next, which--;
   \                     ??cJSON_InsertItemInArray_1: (+1)
   \   00000006   0x681B             LDR      R3,[R3, #+0]
   \   00000008   0x1E49             SUBS     R1,R1,#+1
   \                     ??cJSON_InsertItemInArray_0: (+1)
   \   0000000A   0x2B00             CMP      R3,#+0
   \   0000000C   0xD001             BEQ.N    ??cJSON_InsertItemInArray_2
   \   0000000E   0x2901             CMP      R1,#+1
   \   00000010   0xDAF9             BGE.N    ??cJSON_InsertItemInArray_1
   1070              if (!c)
   \                     ??cJSON_InsertItemInArray_2: (+1)
   \   00000012   0x2B00             CMP      R3,#+0
   \   00000014   0xD103             BNE.N    ??cJSON_InsertItemInArray_3
   1071              {
   1072                  cJSON_AddItemToArray(array, newitem);
   \   00000016   0x0011             MOVS     R1,R2
   \   00000018   0x.... 0x....      BL       cJSON_AddItemToArray
   1073                  return;
   \   0000001C   0xE00A             B.N      ??cJSON_InsertItemInArray_4
   1074              }
   1075              newitem->next = c;
   \                     ??cJSON_InsertItemInArray_3: (+1)
   \   0000001E   0x6013             STR      R3,[R2, #+0]
   1076              newitem->prev = c->prev;
   \   00000020   0x6859             LDR      R1,[R3, #+4]
   \   00000022   0x6051             STR      R1,[R2, #+4]
   1077              c->prev = newitem;
   \   00000024   0x605A             STR      R2,[R3, #+4]
   1078              if (c == array->child) array->child = newitem;
   \   00000026   0x6881             LDR      R1,[R0, #+8]
   \   00000028   0x428B             CMP      R3,R1
   \   0000002A   0xD101             BNE.N    ??cJSON_InsertItemInArray_5
   \   0000002C   0x6082             STR      R2,[R0, #+8]
   \   0000002E   0xE001             B.N      ??cJSON_InsertItemInArray_6
   1079              else newitem->prev->next = newitem;
   \                     ??cJSON_InsertItemInArray_5: (+1)
   \   00000030   0x6850             LDR      R0,[R2, #+4]
   \   00000032   0x6002             STR      R2,[R0, #+0]
   1080          }
   \                     ??cJSON_InsertItemInArray_6: (+1)
   \                     ??cJSON_InsertItemInArray_4: (+1)
   \   00000034   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   1081          void   cJSON_ReplaceItemInArray(cJSON *array, int which, cJSON *newitem)
   1082          {
   \                     cJSON_ReplaceItemInArray: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1083              cJSON *c = array->child;
   \   00000002   0x6883             LDR      R3,[R0, #+8]
   \   00000004   0xE001             B.N      ??cJSON_ReplaceItemInArray_0
   1084              while (c && which > 0) c = c->next, which--;
   \                     ??cJSON_ReplaceItemInArray_1: (+1)
   \   00000006   0x681B             LDR      R3,[R3, #+0]
   \   00000008   0x1E49             SUBS     R1,R1,#+1
   \                     ??cJSON_ReplaceItemInArray_0: (+1)
   \   0000000A   0x2B00             CMP      R3,#+0
   \   0000000C   0xD001             BEQ.N    ??cJSON_ReplaceItemInArray_2
   \   0000000E   0x2901             CMP      R1,#+1
   \   00000010   0xDAF9             BGE.N    ??cJSON_ReplaceItemInArray_1
   1085              if (!c) return;
   \                     ??cJSON_ReplaceItemInArray_2: (+1)
   \   00000012   0x2B00             CMP      R3,#+0
   \   00000014   0xD015             BEQ.N    ??cJSON_ReplaceItemInArray_3
   1086              newitem->next = c->next;
   \                     ??cJSON_ReplaceItemInArray_4: (+1)
   \   00000016   0x6819             LDR      R1,[R3, #+0]
   \   00000018   0x6011             STR      R1,[R2, #+0]
   1087              newitem->prev = c->prev;
   \   0000001A   0x6859             LDR      R1,[R3, #+4]
   \   0000001C   0x6051             STR      R1,[R2, #+4]
   1088              if (newitem->next) newitem->next->prev = newitem;
   \   0000001E   0x6811             LDR      R1,[R2, #+0]
   \   00000020   0x2900             CMP      R1,#+0
   \   00000022   0xD001             BEQ.N    ??cJSON_ReplaceItemInArray_5
   \   00000024   0x6811             LDR      R1,[R2, #+0]
   \   00000026   0x604A             STR      R2,[R1, #+4]
   1089              if (c == array->child) array->child = newitem;
   \                     ??cJSON_ReplaceItemInArray_5: (+1)
   \   00000028   0x6881             LDR      R1,[R0, #+8]
   \   0000002A   0x428B             CMP      R3,R1
   \   0000002C   0xD101             BNE.N    ??cJSON_ReplaceItemInArray_6
   \   0000002E   0x6082             STR      R2,[R0, #+8]
   \   00000030   0xE001             B.N      ??cJSON_ReplaceItemInArray_7
   1090              else newitem->prev->next = newitem;
   \                     ??cJSON_ReplaceItemInArray_6: (+1)
   \   00000032   0x6850             LDR      R0,[R2, #+4]
   \   00000034   0x6002             STR      R2,[R0, #+0]
   1091              c->next = c->prev = 0;
   \                     ??cJSON_ReplaceItemInArray_7: (+1)
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x6058             STR      R0,[R3, #+4]
   \   0000003A   0x6018             STR      R0,[R3, #+0]
   1092              cJSON_Delete(c);
   \   0000003C   0x0018             MOVS     R0,R3
   \   0000003E   0x.... 0x....      BL       cJSON_Delete
   1093          }
   \                     ??cJSON_ReplaceItemInArray_3: (+1)
   \   00000042   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   1094          void   cJSON_ReplaceItemInObject(cJSON *object, const char *string, cJSON *newitem)
   1095          {
   \                     cJSON_ReplaceItemInObject: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   1096              int i = 0;
   \   0000000A   0x2700             MOVS     R7,#+0
   1097              cJSON *c = object->child;
   \   0000000C   0xF8D4 0x8008      LDR      R8,[R4, #+8]
   \   00000010   0xE002             B.N      ??cJSON_ReplaceItemInObject_0
   1098              while(c && cJSON_strcasecmp(c->string, string))i++, c = c->next;
   \                     ??cJSON_ReplaceItemInObject_1: (+1)
   \   00000012   0x1C7F             ADDS     R7,R7,#+1
   \   00000014   0xF8D8 0x8000      LDR      R8,[R8, #+0]
   \                     ??cJSON_ReplaceItemInObject_0: (+1)
   \   00000018   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000001C   0xD006             BEQ.N    ??cJSON_ReplaceItemInObject_2
   \   0000001E   0x0029             MOVS     R1,R5
   \   00000020   0xF8D8 0x0020      LDR      R0,[R8, #+32]
   \   00000024   0x.... 0x....      BL       cJSON_strcasecmp
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD1F2             BNE.N    ??cJSON_ReplaceItemInObject_1
   1099              if(c)
   \                     ??cJSON_ReplaceItemInObject_2: (+1)
   \   0000002C   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000030   0xD008             BEQ.N    ??cJSON_ReplaceItemInObject_3
   1100              {
   1101                  newitem->string = cJSON_strdup(string);
   \   00000032   0x0028             MOVS     R0,R5
   \   00000034   0x.... 0x....      BL       cJSON_strdup
   \   00000038   0x6230             STR      R0,[R6, #+32]
   1102                  cJSON_ReplaceItemInArray(object, i, newitem);
   \   0000003A   0x0032             MOVS     R2,R6
   \   0000003C   0x0039             MOVS     R1,R7
   \   0000003E   0x0020             MOVS     R0,R4
   \   00000040   0x.... 0x....      BL       cJSON_ReplaceItemInArray
   1103              }
   1104          }
   \                     ??cJSON_ReplaceItemInObject_3: (+1)
   \   00000044   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1105          
   1106          /* Create basic types: */

   \                                 In section .text, align 2, keep-with-next
   1107          cJSON *cJSON_CreateNull(void)
   1108          {
   \                     cJSON_CreateNull: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1109              cJSON *item = cJSON_New_Item();
   \   00000002   0x.... 0x....      BL       cJSON_New_Item
   1110              if(item)item->type = cJSON_NULL;
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD001             BEQ.N    ??cJSON_CreateNull_0
   \   0000000A   0x2102             MOVS     R1,#+2
   \   0000000C   0x60C1             STR      R1,[R0, #+12]
   1111              return item;
   \                     ??cJSON_CreateNull_0: (+1)
   \   0000000E   0xBD02             POP      {R1,PC}          ;; return
   1112          }

   \                                 In section .text, align 2, keep-with-next
   1113          cJSON *cJSON_CreateTrue(void)
   1114          {
   \                     cJSON_CreateTrue: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1115              cJSON *item = cJSON_New_Item();
   \   00000002   0x.... 0x....      BL       cJSON_New_Item
   1116              if(item)item->type = cJSON_True;
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD001             BEQ.N    ??cJSON_CreateTrue_0
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0x60C1             STR      R1,[R0, #+12]
   1117              return item;
   \                     ??cJSON_CreateTrue_0: (+1)
   \   0000000E   0xBD02             POP      {R1,PC}          ;; return
   1118          }

   \                                 In section .text, align 2, keep-with-next
   1119          cJSON *cJSON_CreateFalse(void)
   1120          {
   \                     cJSON_CreateFalse: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1121              cJSON *item = cJSON_New_Item();
   \   00000002   0x.... 0x....      BL       cJSON_New_Item
   1122              if(item)item->type = cJSON_False;
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD001             BEQ.N    ??cJSON_CreateFalse_0
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x60C1             STR      R1,[R0, #+12]
   1123              return item;
   \                     ??cJSON_CreateFalse_0: (+1)
   \   0000000E   0xBD02             POP      {R1,PC}          ;; return
   1124          }

   \                                 In section .text, align 2, keep-with-next
   1125          cJSON *cJSON_CreateBool(int b)
   1126          {
   \                     cJSON_CreateBool: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1127              cJSON *item = cJSON_New_Item();
   \   00000004   0x.... 0x....      BL       cJSON_New_Item
   1128              if(item)item->type = b ? cJSON_True : cJSON_False;
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD005             BEQ.N    ??cJSON_CreateBool_0
   \   0000000C   0x2C00             CMP      R4,#+0
   \   0000000E   0xD001             BEQ.N    ??cJSON_CreateBool_1
   \   00000010   0x2101             MOVS     R1,#+1
   \   00000012   0xE000             B.N      ??cJSON_CreateBool_2
   \                     ??cJSON_CreateBool_1: (+1)
   \   00000014   0x2100             MOVS     R1,#+0
   \                     ??cJSON_CreateBool_2: (+1)
   \   00000016   0x60C1             STR      R1,[R0, #+12]
   1129              return item;
   \                     ??cJSON_CreateBool_0: (+1)
   \   00000018   0xBD10             POP      {R4,PC}          ;; return
   1130          }

   \                                 In section .text, align 2, keep-with-next
   1131          cJSON *cJSON_CreateNumber(double num)
   1132          {
   \                     cJSON_CreateNumber: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1133              cJSON *item = cJSON_New_Item();
   \   00000006   0x.... 0x....      BL       cJSON_New_Item
   \   0000000A   0x0006             MOVS     R6,R0
   1134              if(item)
   \   0000000C   0x2E00             CMP      R6,#+0
   \   0000000E   0xD008             BEQ.N    ??cJSON_CreateNumber_0
   1135              {
   1136                  item->type = cJSON_Number;
   \   00000010   0x2003             MOVS     R0,#+3
   \   00000012   0x60F0             STR      R0,[R6, #+12]
   1137                  item->valuedouble = num;
   \   00000014   0xE9C6 0x4506      STRD     R4,R5,[R6, #+24]
   1138                  item->valueint = (int)num;
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0x0029             MOVS     R1,R5
   \   0000001C   0x.... 0x....      BL       __aeabi_d2iz
   \   00000020   0x6170             STR      R0,[R6, #+20]
   1139              }
   1140              return item;
   \                     ??cJSON_CreateNumber_0: (+1)
   \   00000022   0x0030             MOVS     R0,R6
   \   00000024   0xBD70             POP      {R4-R6,PC}       ;; return
   1141          }

   \                                 In section .text, align 2, keep-with-next
   1142          cJSON *cJSON_CreateString(const char *string)
   1143          {
   \                     cJSON_CreateString: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1144              cJSON *item = cJSON_New_Item();
   \   00000004   0x.... 0x....      BL       cJSON_New_Item
   \   00000008   0x0005             MOVS     R5,R0
   1145              if(item)
   \   0000000A   0x2D00             CMP      R5,#+0
   \   0000000C   0xD005             BEQ.N    ??cJSON_CreateString_0
   1146              {
   1147                  item->type = cJSON_String;
   \   0000000E   0x2004             MOVS     R0,#+4
   \   00000010   0x60E8             STR      R0,[R5, #+12]
   1148                  item->valuestring = cJSON_strdup(string);
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0x.... 0x....      BL       cJSON_strdup
   \   00000018   0x6128             STR      R0,[R5, #+16]
   1149              }
   1150              return item;
   \                     ??cJSON_CreateString_0: (+1)
   \   0000001A   0x0028             MOVS     R0,R5
   \   0000001C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1151          }

   \                                 In section .text, align 2, keep-with-next
   1152          cJSON *cJSON_CreateArray(void)
   1153          {
   \                     cJSON_CreateArray: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1154              cJSON *item = cJSON_New_Item();
   \   00000002   0x.... 0x....      BL       cJSON_New_Item
   1155              if(item)item->type = cJSON_Array;
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD001             BEQ.N    ??cJSON_CreateArray_0
   \   0000000A   0x2105             MOVS     R1,#+5
   \   0000000C   0x60C1             STR      R1,[R0, #+12]
   1156              return item;
   \                     ??cJSON_CreateArray_0: (+1)
   \   0000000E   0xBD02             POP      {R1,PC}          ;; return
   1157          }

   \                                 In section .text, align 2, keep-with-next
   1158          cJSON *cJSON_CreateObject(void)
   1159          {
   \                     cJSON_CreateObject: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1160              cJSON *item = cJSON_New_Item();
   \   00000002   0x.... 0x....      BL       cJSON_New_Item
   1161              if(item)item->type = cJSON_Object;
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD001             BEQ.N    ??cJSON_CreateObject_0
   \   0000000A   0x2106             MOVS     R1,#+6
   \   0000000C   0x60C1             STR      R1,[R0, #+12]
   1162              return item;
   \                     ??cJSON_CreateObject_0: (+1)
   \   0000000E   0xBD02             POP      {R1,PC}          ;; return
   1163          }
   1164          
   1165          /* Create Arrays: */

   \                                 In section .text, align 2, keep-with-next
   1166          cJSON *cJSON_CreateIntArray(const int *numbers, int count)
   1167          {
   \                     cJSON_CreateIntArray: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   1168              int i;
   1169              cJSON *n = 0, *p = 0, *a = cJSON_CreateArray();
   \   00000008   0x2700             MOVS     R7,#+0
   \   0000000A   0xF05F 0x0800      MOVS     R8,#+0
   \   0000000E   0x.... 0x....      BL       cJSON_CreateArray
   \   00000012   0x4681             MOV      R9,R0
   1170              for(i = 0; a && i < count; i++)
   \   00000014   0x2600             MOVS     R6,#+0
   \   00000016   0xE005             B.N      ??cJSON_CreateIntArray_0
   1171              {
   1172                  n = cJSON_CreateNumber(numbers[i]);
   1173                  if(!i)a->child = n;
   1174                  else suffix_object(p, n);
   \                     ??cJSON_CreateIntArray_1: (+1)
   \   00000018   0x0039             MOVS     R1,R7
   \   0000001A   0x4640             MOV      R0,R8
   \   0000001C   0x.... 0x....      BL       suffix_object
   1175                  p = n;
   \                     ??cJSON_CreateIntArray_2: (+1)
   \   00000020   0x46B8             MOV      R8,R7
   \   00000022   0x1C76             ADDS     R6,R6,#+1
   \                     ??cJSON_CreateIntArray_0: (+1)
   \   00000024   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000028   0xD00D             BEQ.N    ??cJSON_CreateIntArray_3
   \   0000002A   0x42AE             CMP      R6,R5
   \   0000002C   0xDA0B             BGE.N    ??cJSON_CreateIntArray_3
   \   0000002E   0xF854 0x0026      LDR      R0,[R4, R6, LSL #+2]
   \   00000032   0x.... 0x....      BL       __aeabi_i2d
   \   00000036   0x.... 0x....      BL       cJSON_CreateNumber
   \   0000003A   0x0007             MOVS     R7,R0
   \   0000003C   0x2E00             CMP      R6,#+0
   \   0000003E   0xD1EB             BNE.N    ??cJSON_CreateIntArray_1
   \   00000040   0xF8C9 0x7008      STR      R7,[R9, #+8]
   \   00000044   0xE7EC             B.N      ??cJSON_CreateIntArray_2
   1176              }
   1177              return a;
   \                     ??cJSON_CreateIntArray_3: (+1)
   \   00000046   0x4648             MOV      R0,R9
   \   00000048   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1178          }

   \                                 In section .text, align 2, keep-with-next
   1179          cJSON *cJSON_CreateFloatArray(const float *numbers, int count)
   1180          {
   \                     cJSON_CreateFloatArray: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   1181              int i;
   1182              cJSON *n = 0, *p = 0, *a = cJSON_CreateArray();
   \   00000008   0x2700             MOVS     R7,#+0
   \   0000000A   0xF05F 0x0800      MOVS     R8,#+0
   \   0000000E   0x.... 0x....      BL       cJSON_CreateArray
   \   00000012   0x4681             MOV      R9,R0
   1183              for(i = 0; a && i < count; i++)
   \   00000014   0x2600             MOVS     R6,#+0
   \   00000016   0xE005             B.N      ??cJSON_CreateFloatArray_0
   1184              {
   1185                  n = cJSON_CreateNumber(numbers[i]);
   1186                  if(!i)a->child = n;
   1187                  else suffix_object(p, n);
   \                     ??cJSON_CreateFloatArray_1: (+1)
   \   00000018   0x0039             MOVS     R1,R7
   \   0000001A   0x4640             MOV      R0,R8
   \   0000001C   0x.... 0x....      BL       suffix_object
   1188                  p = n;
   \                     ??cJSON_CreateFloatArray_2: (+1)
   \   00000020   0x46B8             MOV      R8,R7
   \   00000022   0x1C76             ADDS     R6,R6,#+1
   \                     ??cJSON_CreateFloatArray_0: (+1)
   \   00000024   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000028   0xD00D             BEQ.N    ??cJSON_CreateFloatArray_3
   \   0000002A   0x42AE             CMP      R6,R5
   \   0000002C   0xDA0B             BGE.N    ??cJSON_CreateFloatArray_3
   \   0000002E   0xF854 0x0026      LDR      R0,[R4, R6, LSL #+2]
   \   00000032   0x.... 0x....      BL       __aeabi_f2d
   \   00000036   0x.... 0x....      BL       cJSON_CreateNumber
   \   0000003A   0x0007             MOVS     R7,R0
   \   0000003C   0x2E00             CMP      R6,#+0
   \   0000003E   0xD1EB             BNE.N    ??cJSON_CreateFloatArray_1
   \   00000040   0xF8C9 0x7008      STR      R7,[R9, #+8]
   \   00000044   0xE7EC             B.N      ??cJSON_CreateFloatArray_2
   1189              }
   1190              return a;
   \                     ??cJSON_CreateFloatArray_3: (+1)
   \   00000046   0x4648             MOV      R0,R9
   \   00000048   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1191          }

   \                                 In section .text, align 2, keep-with-next
   1192          cJSON *cJSON_CreateDoubleArray(const double *numbers, int count)
   1193          {
   \                     cJSON_CreateDoubleArray: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   1194              int i;
   1195              cJSON *n = 0, *p = 0, *a = cJSON_CreateArray();
   \   00000008   0xF05F 0x0900      MOVS     R9,#+0
   \   0000000C   0x2700             MOVS     R7,#+0
   \   0000000E   0x.... 0x....      BL       cJSON_CreateArray
   \   00000012   0x0006             MOVS     R6,R0
   1196              for(i = 0; a && i < count; i++)
   \   00000014   0xF05F 0x0800      MOVS     R8,#+0
   \   00000018   0xE006             B.N      ??cJSON_CreateDoubleArray_0
   1197              {
   1198                  n = cJSON_CreateNumber(numbers[i]);
   1199                  if(!i)a->child = n;
   1200                  else suffix_object(p, n);
   \                     ??cJSON_CreateDoubleArray_1: (+1)
   \   0000001A   0x4649             MOV      R1,R9
   \   0000001C   0x0038             MOVS     R0,R7
   \   0000001E   0x.... 0x....      BL       suffix_object
   1201                  p = n;
   \                     ??cJSON_CreateDoubleArray_2: (+1)
   \   00000022   0x464F             MOV      R7,R9
   \   00000024   0xF118 0x0801      ADDS     R8,R8,#+1
   \                     ??cJSON_CreateDoubleArray_0: (+1)
   \   00000028   0x2E00             CMP      R6,#+0
   \   0000002A   0xD00E             BEQ.N    ??cJSON_CreateDoubleArray_3
   \   0000002C   0x45A8             CMP      R8,R5
   \   0000002E   0xDA0C             BGE.N    ??cJSON_CreateDoubleArray_3
   \   00000030   0xEB14 0x02C8      ADDS     R2,R4,R8, LSL #+3
   \   00000034   0xE9D2 0x0100      LDRD     R0,R1,[R2, #+0]
   \   00000038   0x.... 0x....      BL       cJSON_CreateNumber
   \   0000003C   0x4681             MOV      R9,R0
   \   0000003E   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000042   0xD1EA             BNE.N    ??cJSON_CreateDoubleArray_1
   \   00000044   0xF8C6 0x9008      STR      R9,[R6, #+8]
   \   00000048   0xE7EB             B.N      ??cJSON_CreateDoubleArray_2
   1202              }
   1203              return a;
   \                     ??cJSON_CreateDoubleArray_3: (+1)
   \   0000004A   0x0030             MOVS     R0,R6
   \   0000004C   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1204          }

   \                                 In section .text, align 2, keep-with-next
   1205          cJSON *cJSON_CreateStringArray(const char **strings, int count)
   1206          {
   \                     cJSON_CreateStringArray: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   1207              int i;
   1208              cJSON *n = 0, *p = 0, *a = cJSON_CreateArray();
   \   00000008   0x2700             MOVS     R7,#+0
   \   0000000A   0xF05F 0x0800      MOVS     R8,#+0
   \   0000000E   0x.... 0x....      BL       cJSON_CreateArray
   \   00000012   0x4681             MOV      R9,R0
   1209              for(i = 0; a && i < count; i++)
   \   00000014   0x2600             MOVS     R6,#+0
   \   00000016   0xE005             B.N      ??cJSON_CreateStringArray_0
   1210              {
   1211                  n = cJSON_CreateString(strings[i]);
   1212                  if(!i)a->child = n;
   1213                  else suffix_object(p, n);
   \                     ??cJSON_CreateStringArray_1: (+1)
   \   00000018   0x0039             MOVS     R1,R7
   \   0000001A   0x4640             MOV      R0,R8
   \   0000001C   0x.... 0x....      BL       suffix_object
   1214                  p = n;
   \                     ??cJSON_CreateStringArray_2: (+1)
   \   00000020   0x46B8             MOV      R8,R7
   \   00000022   0x1C76             ADDS     R6,R6,#+1
   \                     ??cJSON_CreateStringArray_0: (+1)
   \   00000024   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000028   0xD00B             BEQ.N    ??cJSON_CreateStringArray_3
   \   0000002A   0x42AE             CMP      R6,R5
   \   0000002C   0xDA09             BGE.N    ??cJSON_CreateStringArray_3
   \   0000002E   0xF854 0x0026      LDR      R0,[R4, R6, LSL #+2]
   \   00000032   0x.... 0x....      BL       cJSON_CreateString
   \   00000036   0x0007             MOVS     R7,R0
   \   00000038   0x2E00             CMP      R6,#+0
   \   0000003A   0xD1ED             BNE.N    ??cJSON_CreateStringArray_1
   \   0000003C   0xF8C9 0x7008      STR      R7,[R9, #+8]
   \   00000040   0xE7EE             B.N      ??cJSON_CreateStringArray_2
   1215              }
   1216              return a;
   \                     ??cJSON_CreateStringArray_3: (+1)
   \   00000042   0x4648             MOV      R0,R9
   \   00000044   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1217          }
   1218          
   1219          /* Duplication */

   \                                 In section .text, align 2, keep-with-next
   1220          cJSON *cJSON_Duplicate(cJSON *item, int recurse)
   1221          {
   \                     cJSON_Duplicate: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   1222              cJSON *newitem, *cptr, *nptr = 0, *newchild;
   \   00000006   0x2700             MOVS     R7,#+0
   1223              /* Bail on bad ptr */
   1224              if (!item) return 0;
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD101             BNE.N    ??cJSON_Duplicate_0
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xE04B             B.N      ??cJSON_Duplicate_1
   1225              /* Create new item */
   1226              newitem = cJSON_New_Item();
   \                     ??cJSON_Duplicate_0: (+1)
   \   00000010   0x.... 0x....      BL       cJSON_New_Item
   \   00000014   0x0006             MOVS     R6,R0
   1227              if (!newitem) return 0;
   \   00000016   0x2E00             CMP      R6,#+0
   \   00000018   0xD101             BNE.N    ??cJSON_Duplicate_2
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xE044             B.N      ??cJSON_Duplicate_1
   1228              /* Copy over all vars */
   1229              newitem->type = item->type & (~cJSON_IsReference), newitem->valueint = item->valueint, newitem->valuedouble = item->valuedouble;
   \                     ??cJSON_Duplicate_2: (+1)
   \   0000001E   0x68E0             LDR      R0,[R4, #+12]
   \   00000020   0xF430 0x7080      BICS     R0,R0,#0x100
   \   00000024   0x60F0             STR      R0,[R6, #+12]
   \   00000026   0x6960             LDR      R0,[R4, #+20]
   \   00000028   0x6170             STR      R0,[R6, #+20]
   \   0000002A   0xE9D4 0x0106      LDRD     R0,R1,[R4, #+24]
   \   0000002E   0xE9C6 0x0106      STRD     R0,R1,[R6, #+24]
   1230              if (item->valuestring)
   \   00000032   0x6920             LDR      R0,[R4, #+16]
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD00B             BEQ.N    ??cJSON_Duplicate_3
   1231              {
   1232                  newitem->valuestring = cJSON_strdup(item->valuestring);
   \   00000038   0x6920             LDR      R0,[R4, #+16]
   \   0000003A   0x.... 0x....      BL       cJSON_strdup
   \   0000003E   0x6130             STR      R0,[R6, #+16]
   1233                  if (!newitem->valuestring)
   \   00000040   0x6930             LDR      R0,[R6, #+16]
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD104             BNE.N    ??cJSON_Duplicate_3
   1234                  {
   1235                      cJSON_Delete(newitem);
   \   00000046   0x0030             MOVS     R0,R6
   \   00000048   0x.... 0x....      BL       cJSON_Delete
   1236                      return 0;
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0xE02B             B.N      ??cJSON_Duplicate_1
   1237                  }
   1238              }
   1239              if (item->string)
   \                     ??cJSON_Duplicate_3: (+1)
   \   00000050   0x6A20             LDR      R0,[R4, #+32]
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD00B             BEQ.N    ??cJSON_Duplicate_4
   1240              {
   1241                  newitem->string = cJSON_strdup(item->string);
   \   00000056   0x6A20             LDR      R0,[R4, #+32]
   \   00000058   0x.... 0x....      BL       cJSON_strdup
   \   0000005C   0x6230             STR      R0,[R6, #+32]
   1242                  if (!newitem->string)
   \   0000005E   0x6A30             LDR      R0,[R6, #+32]
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xD104             BNE.N    ??cJSON_Duplicate_4
   1243                  {
   1244                      cJSON_Delete(newitem);
   \   00000064   0x0030             MOVS     R0,R6
   \   00000066   0x.... 0x....      BL       cJSON_Delete
   1245                      return 0;
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0xE01C             B.N      ??cJSON_Duplicate_1
   1246                  }
   1247              }
   1248              /* If non-recursive, then we're done! */
   1249              if (!recurse) return newitem;
   \                     ??cJSON_Duplicate_4: (+1)
   \   0000006E   0x2D00             CMP      R5,#+0
   \   00000070   0xD101             BNE.N    ??cJSON_Duplicate_5
   \   00000072   0x0030             MOVS     R0,R6
   \   00000074   0xE018             B.N      ??cJSON_Duplicate_1
   1250              /* Walk the ->next chain for the child. */
   1251              cptr = item->child;
   \                     ??cJSON_Duplicate_5: (+1)
   \   00000076   0x68A4             LDR      R4,[R4, #+8]
   \   00000078   0xE002             B.N      ??cJSON_Duplicate_6
   1252              while (cptr)
   1253              {
   1254                  newchild = cJSON_Duplicate(cptr, 1);		/* Duplicate (with recurse) each item in the ->next chain */
   1255                  if (!newchild)
   1256                  {
   1257                      cJSON_Delete(newitem);
   1258                      return 0;
   1259                  }
   1260                  if (nptr)
   1261                  {
   1262                      nptr->next = newchild, newchild->prev = nptr;    /* If newitem->child already set, then crosswire ->prev and ->next and move on */
   1263                      nptr = newchild;
   1264                  }
   1265                  else
   1266                  {
   1267                      newitem->child = newchild;    /* Set newitem->child and move to it */
   \                     ??cJSON_Duplicate_7: (+1)
   \   0000007A   0x60B0             STR      R0,[R6, #+8]
   1268                      nptr = newchild;
   \   0000007C   0x0007             MOVS     R7,R0
   1269                  }
   1270                  cptr = cptr->next;
   \                     ??cJSON_Duplicate_8: (+1)
   \   0000007E   0x6824             LDR      R4,[R4, #+0]
   \                     ??cJSON_Duplicate_6: (+1)
   \   00000080   0x2C00             CMP      R4,#+0
   \   00000082   0xD010             BEQ.N    ??cJSON_Duplicate_9
   \   00000084   0x2101             MOVS     R1,#+1
   \   00000086   0x0020             MOVS     R0,R4
   \   00000088   0xF7FF 0xFFBA      BL       cJSON_Duplicate
   \   0000008C   0x2800             CMP      R0,#+0
   \   0000008E   0xD104             BNE.N    ??cJSON_Duplicate_10
   \   00000090   0x0030             MOVS     R0,R6
   \   00000092   0x.... 0x....      BL       cJSON_Delete
   \   00000096   0x2000             MOVS     R0,#+0
   \   00000098   0xE006             B.N      ??cJSON_Duplicate_1
   \                     ??cJSON_Duplicate_10: (+1)
   \   0000009A   0x2F00             CMP      R7,#+0
   \   0000009C   0xD0ED             BEQ.N    ??cJSON_Duplicate_7
   \   0000009E   0x6038             STR      R0,[R7, #+0]
   \   000000A0   0x6047             STR      R7,[R0, #+4]
   \   000000A2   0x0007             MOVS     R7,R0
   \   000000A4   0xE7EB             B.N      ??cJSON_Duplicate_8
   1271              }
   1272              return newitem;
   \                     ??cJSON_Duplicate_9: (+1)
   \   000000A6   0x0030             MOVS     R0,R6
   \                     ??cJSON_Duplicate_1: (+1)
   \   000000A8   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1273          }
   1274          

   \                                 In section .text, align 2, keep-with-next
   1275          void cJSON_Minify(char *json)
   1276          {
   1277              char *into = json;
   \                     cJSON_Minify: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   \   00000002   0xE000             B.N      ??cJSON_Minify_0
   1278              while (*json)
   1279              {
   1280                  if (*json == ' ') json++;
   \                     ??cJSON_Minify_1: (+1)
   \   00000004   0x1C40             ADDS     R0,R0,#+1
   \                     ??cJSON_Minify_0: (+1)
   \   00000006   0x7802             LDRB     R2,[R0, #+0]
   \   00000008   0x2A00             CMP      R2,#+0
   \   0000000A   0xD054             BEQ.N    ??cJSON_Minify_2
   \   0000000C   0x7802             LDRB     R2,[R0, #+0]
   \   0000000E   0x2A20             CMP      R2,#+32
   \   00000010   0xD0F8             BEQ.N    ??cJSON_Minify_1
   1281                  else if (*json == '\t') json++;	/* Whitespace characters. */
   \   00000012   0x7802             LDRB     R2,[R0, #+0]
   \   00000014   0x2A09             CMP      R2,#+9
   \   00000016   0xD101             BNE.N    ??cJSON_Minify_3
   \   00000018   0x1C40             ADDS     R0,R0,#+1
   \   0000001A   0xE7F4             B.N      ??cJSON_Minify_0
   1282                  else if (*json == '\r') json++;
   \                     ??cJSON_Minify_3: (+1)
   \   0000001C   0x7802             LDRB     R2,[R0, #+0]
   \   0000001E   0x2A0D             CMP      R2,#+13
   \   00000020   0xD101             BNE.N    ??cJSON_Minify_4
   \   00000022   0x1C40             ADDS     R0,R0,#+1
   \   00000024   0xE7EF             B.N      ??cJSON_Minify_0
   1283                  else if (*json == '\n') json++;
   \                     ??cJSON_Minify_4: (+1)
   \   00000026   0x7802             LDRB     R2,[R0, #+0]
   \   00000028   0x2A0A             CMP      R2,#+10
   \   0000002A   0xD101             BNE.N    ??cJSON_Minify_5
   \   0000002C   0x1C40             ADDS     R0,R0,#+1
   \   0000002E   0xE7EA             B.N      ??cJSON_Minify_0
   1284                  else if (*json == '/' && json[1] == '/')  while (*json && *json != '\n') json++;	/* double-slash comments, to end of line. */
   \                     ??cJSON_Minify_5: (+1)
   \   00000030   0x7802             LDRB     R2,[R0, #+0]
   \   00000032   0x2A2F             CMP      R2,#+47
   \   00000034   0xD10A             BNE.N    ??cJSON_Minify_6
   \   00000036   0x7842             LDRB     R2,[R0, #+1]
   \   00000038   0x2A2F             CMP      R2,#+47
   \   0000003A   0xD107             BNE.N    ??cJSON_Minify_6
   \                     ??cJSON_Minify_7: (+1)
   \   0000003C   0x7802             LDRB     R2,[R0, #+0]
   \   0000003E   0x2A00             CMP      R2,#+0
   \   00000040   0xD0E1             BEQ.N    ??cJSON_Minify_0
   \   00000042   0x7802             LDRB     R2,[R0, #+0]
   \   00000044   0x2A0A             CMP      R2,#+10
   \   00000046   0xD0DE             BEQ.N    ??cJSON_Minify_0
   \   00000048   0x1C40             ADDS     R0,R0,#+1
   \   0000004A   0xE7F7             B.N      ??cJSON_Minify_7
   1285                  else if (*json == '/' && json[1] == '*')
   \                     ??cJSON_Minify_6: (+1)
   \   0000004C   0x7802             LDRB     R2,[R0, #+0]
   \   0000004E   0x2A2F             CMP      R2,#+47
   \   00000050   0xD102             BNE.N    ??cJSON_Minify_8
   \   00000052   0x7842             LDRB     R2,[R0, #+1]
   \   00000054   0x2A2A             CMP      R2,#+42
   \   00000056   0xD008             BEQ.N    ??cJSON_Minify_9
   1286                  {
   1287                      while (*json && !(*json == '*' && json[1] == '/')) json++;    /* multiline comments. */
   1288                      json += 2;
   1289                  }
   1290                  else if (*json == '\"')
   \                     ??cJSON_Minify_8: (+1)
   \   00000058   0x7802             LDRB     R2,[R0, #+0]
   \   0000005A   0x2A22             CMP      R2,#+34
   \   0000005C   0xD126             BNE.N    ??cJSON_Minify_10
   1291                  {
   1292                      *into++ = *json++;    /* string literals, which are \" sensitive. */
   \   0000005E   0x7802             LDRB     R2,[R0, #+0]
   \   00000060   0x700A             STRB     R2,[R1, #+0]
   \   00000062   0x1C40             ADDS     R0,R0,#+1
   \   00000064   0x1C49             ADDS     R1,R1,#+1
   \   00000066   0xE016             B.N      ??cJSON_Minify_11
   \                     ??cJSON_Minify_12: (+1)
   \   00000068   0x1C40             ADDS     R0,R0,#+1
   \                     ??cJSON_Minify_9: (+1)
   \   0000006A   0x7802             LDRB     R2,[R0, #+0]
   \   0000006C   0x2A00             CMP      R2,#+0
   \   0000006E   0xD005             BEQ.N    ??cJSON_Minify_13
   \   00000070   0x7802             LDRB     R2,[R0, #+0]
   \   00000072   0x2A2A             CMP      R2,#+42
   \   00000074   0xD1F8             BNE.N    ??cJSON_Minify_12
   \   00000076   0x7842             LDRB     R2,[R0, #+1]
   \   00000078   0x2A2F             CMP      R2,#+47
   \   0000007A   0xD1F5             BNE.N    ??cJSON_Minify_12
   \                     ??cJSON_Minify_13: (+1)
   \   0000007C   0x1C80             ADDS     R0,R0,#+2
   \   0000007E   0xE7C2             B.N      ??cJSON_Minify_0
   1293                      while (*json && *json != '\"')
   1294                      {
   1295                          if (*json == '\\') *into++ = *json++;
   \                     ??cJSON_Minify_14: (+1)
   \   00000080   0x7802             LDRB     R2,[R0, #+0]
   \   00000082   0x2A5C             CMP      R2,#+92
   \   00000084   0xD103             BNE.N    ??cJSON_Minify_15
   \   00000086   0x7802             LDRB     R2,[R0, #+0]
   \   00000088   0x700A             STRB     R2,[R1, #+0]
   \   0000008A   0x1C40             ADDS     R0,R0,#+1
   \   0000008C   0x1C49             ADDS     R1,R1,#+1
   1296                          *into++ = *json++;
   \                     ??cJSON_Minify_15: (+1)
   \   0000008E   0x7802             LDRB     R2,[R0, #+0]
   \   00000090   0x700A             STRB     R2,[R1, #+0]
   \   00000092   0x1C40             ADDS     R0,R0,#+1
   \   00000094   0x1C49             ADDS     R1,R1,#+1
   1297                      }*into++ = *json++;
   \                     ??cJSON_Minify_11: (+1)
   \   00000096   0x7802             LDRB     R2,[R0, #+0]
   \   00000098   0x2A00             CMP      R2,#+0
   \   0000009A   0xD002             BEQ.N    ??cJSON_Minify_16
   \   0000009C   0x7802             LDRB     R2,[R0, #+0]
   \   0000009E   0x2A22             CMP      R2,#+34
   \   000000A0   0xD1EE             BNE.N    ??cJSON_Minify_14
   \                     ??cJSON_Minify_16: (+1)
   \   000000A2   0x7802             LDRB     R2,[R0, #+0]
   \   000000A4   0x700A             STRB     R2,[R1, #+0]
   \   000000A6   0x1C40             ADDS     R0,R0,#+1
   \   000000A8   0x1C49             ADDS     R1,R1,#+1
   \   000000AA   0xE7AC             B.N      ??cJSON_Minify_0
   1298                  }
   1299                  else *into++ = *json++;			/* All other characters. */
   \                     ??cJSON_Minify_10: (+1)
   \   000000AC   0x7802             LDRB     R2,[R0, #+0]
   \   000000AE   0x700A             STRB     R2,[R1, #+0]
   \   000000B0   0x1C40             ADDS     R0,R0,#+1
   \   000000B2   0x1C49             ADDS     R1,R1,#+1
   \   000000B4   0xE7A7             B.N      ??cJSON_Minify_0
   1300              }
   1301              *into = 0;	/* and null-terminate. */
   \                     ??cJSON_Minify_2: (+1)
   \   000000B6   0x2000             MOVS     R0,#+0
   \   000000B8   0x7008             STRB     R0,[R1, #+0]
   1302          }
   \   000000BA   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x30 0x00          DC8      "0",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   0x25 0x64          DC8      0x25, 0x64, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x25 0x65          DC8      0x25, 0x65, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0x25 0x66          DC8      0x25, 0x66, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x22 0x22          DC8      0x22, 0x22, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x........         DC32     ep

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \   00000000   0x........         DC32     cJSON_malloc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \   00000000   0x........         DC32     malloc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_3:
   \   00000000   0x........         DC32     free

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_4:
   \   00000000   0x........         DC32     cJSON_free

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_5:
   \   00000000   0x3FF00000         DC32     0x3ff00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_6:
   \   00000000   0xBFF00000         DC32     0xbff00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_7:
   \   00000000   0x40240000         DC32     0x40240000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0x5B 0x5D          DC8      0x5B, 0x5D, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   0x3CB00000         DC32     0x3cb00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \   00000000   0xFFC00001         DC32     0xffc00001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \   00000000   0x41DFFFFF         DC32     0x41dfffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_3:
   \   00000000   0xC1E00000         DC32     0xc1e00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_4:
   \   00000000   0xE4C2F344         DC32     0xe4c2f344

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_5:
   \   00000000   0x4C63E9E4         DC32     0x4c63e9e4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_6:
   \   00000000   0x........         DC32     `?<Constant "%.0f">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_7:
   \   00000000   0xA0B5ED8D         DC32     0xa0b5ed8d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_8:
   \   00000000   0x3EB0C6F7         DC32     0x3eb0c6f7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_9:
   \   00000000   0x41CDCD65         DC32     0x41cdcd65

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_10:
   \   00000000   0x........         DC32     firstByteMark

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_11:
   \   00000000   0x........         DC32     ep

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   0x........         DC32     `?<Constant "\\"\\\\\\b\\f\\n\\r\\t">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \   00000000   0x........         DC32     `?<Constant "u%04x">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_1:
   \   00000000   0x........         DC32     cJSON_malloc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_2:
   \   00000000   0x........         DC32     `?<Constant "null">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_3:
   \   00000000   0x........         DC32     `?<Constant "false">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_4:
   \   00000000   0x........         DC32     `?<Constant "true">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_5:
   \   00000000   0x........         DC32     cJSON_free

   \                                 In section .rodata, align 2
   \   00000000   0x30 0x00          DC8 "0"

   \                                 In section .rodata, align 4
   \   00000000   0x25 0x64          DC8 "%d"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "%.0f">`:
   \   00000000   0x25 0x2E          DC8 "%.0f"
   \              0x30 0x66    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \   00000000   0x25 0x65          DC8 "%e"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 4
   \   00000000   0x25 0x66          DC8 "%f"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 4
   \   00000000   0x22 0x22          DC8 "\"\""
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\"\\\\\\b\\f\\n\\r\\t">`:
   \   00000000   0x22 0x5C          DC8 "\"\\\010\014\012\015\t"
   \              0x08 0x0C    
   \              0x0A 0x0D    
   \              0x09 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "u%04x">`:
   \   00000000   0x75 0x25          DC8 "u%04x"
   \              0x30 0x34    
   \              0x78 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "null">`:
   \   00000000   0x6E 0x75          DC8 "null"
   \              0x6C 0x6C    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "false">`:
   \   00000000   0x66 0x61          DC8 "false"
   \              0x6C 0x73    
   \              0x65 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "true">`:
   \   00000000   0x74 0x72          DC8 "true"
   \              0x75 0x65    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \   00000000   0x5B 0x5D          DC8 "[]"
   \              0x00         
   \   00000003   0x00               DC8 0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   cJSON_AddItemReferenceToArray
         8   -> cJSON_AddItemToArray
         8   -> create_reference
      16   cJSON_AddItemReferenceToObject
        16   -> cJSON_AddItemToObject
        16   -> create_reference
       8   cJSON_AddItemToArray
         8   -> suffix_object
      16   cJSON_AddItemToObject
        16   -- Indirect call
        16   -> cJSON_AddItemToArray
        16   -> cJSON_strdup
      16   cJSON_AddItemToObjectCS
        16   -- Indirect call
        16   -> cJSON_AddItemToArray
       8   cJSON_CreateArray
         8   -> cJSON_New_Item
       8   cJSON_CreateBool
         8   -> cJSON_New_Item
      32   cJSON_CreateDoubleArray
        32   -> cJSON_CreateArray
        32   -> cJSON_CreateNumber
        32   -> suffix_object
       8   cJSON_CreateFalse
         8   -> cJSON_New_Item
      32   cJSON_CreateFloatArray
        32   -> __aeabi_f2d
        32   -> cJSON_CreateArray
        32   -> cJSON_CreateNumber
        32   -> suffix_object
      32   cJSON_CreateIntArray
        32   -> __aeabi_i2d
        32   -> cJSON_CreateArray
        32   -> cJSON_CreateNumber
        32   -> suffix_object
       8   cJSON_CreateNull
         8   -> cJSON_New_Item
      16   cJSON_CreateNumber
        16   -> __aeabi_d2iz
        16   -> cJSON_New_Item
       8   cJSON_CreateObject
         8   -> cJSON_New_Item
      16   cJSON_CreateString
        16   -> cJSON_New_Item
        16   -> cJSON_strdup
      32   cJSON_CreateStringArray
        32   -> cJSON_CreateArray
        32   -> cJSON_CreateString
        32   -> suffix_object
       8   cJSON_CreateTrue
         8   -> cJSON_New_Item
      16   cJSON_Delete
        16   -- Indirect call
        16   -> cJSON_Delete
       8   cJSON_DeleteItemFromArray
         8   -> cJSON_Delete
         8   -> cJSON_DetachItemFromArray
       8   cJSON_DeleteItemFromObject
         8   -> cJSON_Delete
         8   -> cJSON_DetachItemFromObject
       0   cJSON_DetachItemFromArray
      24   cJSON_DetachItemFromObject
        24   -> cJSON_DetachItemFromArray
        24   -> cJSON_strcasecmp
      24   cJSON_Duplicate
        24   -> cJSON_Delete
        24   -> cJSON_Duplicate
        24   -> cJSON_New_Item
        24   -> cJSON_strdup
       0   cJSON_GetArrayItem
       0   cJSON_GetArraySize
       0   cJSON_GetErrorPtr
      16   cJSON_GetObjectItem
        16   -> cJSON_strcasecmp
       0   cJSON_InitHooks
       8   cJSON_InsertItemInArray
         8   -> cJSON_AddItemToArray
       0   cJSON_Minify
       8   cJSON_New_Item
         8   -- Indirect call
         8   -> memset
       8   cJSON_Parse
         8   -> cJSON_ParseWithOpts
      24   cJSON_ParseWithOpts
        24   -> cJSON_Delete
        24   -> cJSON_New_Item
        24   -> parse_value
        24   -> skip
       8   cJSON_Print
         8   -> print_value
      32   cJSON_PrintBuffered
        32   -- Indirect call
        32   -> print_value
       8   cJSON_PrintUnformatted
         8   -> print_value
       8   cJSON_ReplaceItemInArray
         8   -> cJSON_Delete
      24   cJSON_ReplaceItemInObject
        24   -> cJSON_ReplaceItemInArray
        24   -> cJSON_strcasecmp
        24   -> cJSON_strdup
      16   cJSON_strcasecmp
        16   -> tolower
      16   cJSON_strdup
        16   -- Indirect call
        16   -> memcpy
        16   -> strlen
      16   create_reference
        16   -> cJSON_New_Item
        16   -> memcpy
      16   ensure
        16   -- Indirect call
        16   -> memcpy
        16   -> pow2gt
      16   parse_array
        16   -> cJSON_New_Item
        16   -> parse_value
        16   -> skip
       0   parse_hex4
      48   parse_number
        48   -> __aeabi_d2iz
        48   -> __aeabi_dadd
        48   -> __aeabi_dmul
        48   -> __aeabi_i2d
        48   -> pow
      16   parse_object
        16   -> cJSON_New_Item
        16   -> parse_string
        16   -> parse_value
        16   -> skip
      24   parse_string
        24   -- Indirect call
        24   -> parse_hex4
      16   parse_value
        16   -> parse_array
        16   -> parse_number
        16   -> parse_object
        16   -> parse_string
        16   -> strncmp
       0   pow2gt
      56   print_array
        56   -- Indirect call
        56   -> ensure
        56   -> memcpy
        56   -> memset
        56   -> print_value
        56   -> strcpy
        56   -> strlen
        56   -> update
      24   print_number
        24   -- Indirect call
        24   -> __aeabi_cdcmpeq
        24   -> __aeabi_cdcmple
        24   -> __aeabi_cdrcmple
        24   -> __aeabi_dsub
        24   -> __aeabi_i2d
        24   -> ensure
        24   -> floor
        24   -> sprintf
        24   -> strcpy
      64   print_object
        64   -- Indirect call
        64   -> ensure
        64   -> memcpy
        64   -> memset
        64   -> print_string_ptr
        64   -> print_value
        64   -> strcpy
        64   -> strlen
        64   -> update
       8   print_string
         8   -> print_string_ptr
      32   print_string_ptr
        32   -- Indirect call
        32   -> ensure
        32   -> sprintf
        32   -> strchr
        32   -> strcpy
      16   print_value
        16   -> cJSON_strdup
        16   -> ensure
        16   -> print_array
        16   -> print_number
        16   -> print_object
        16   -> print_string
        16   -> strcpy
       0   skip
       0   suffix_object
       8   update
         8   -> strlen


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       8  ?<Constant "%.0f">
       4  ?<Constant "%d">
       4  ?<Constant "%e">
       4  ?<Constant "%f">
       2  ?<Constant "0">
       4  ?<Constant "[]">
       4  ?<Constant "\"\"">
       8  ?<Constant "\"\\\b\f\n\r\t">
       8  ?<Constant "false">
       8  ?<Constant "null">
       8  ?<Constant "true">
       8  ?<Constant "u%04x">
       4  ??DataTable12
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_2
       4  ??DataTable14_3
       4  ??DataTable14_4
       4  ??DataTable14_5
       4  ??DataTable14_6
       4  ??DataTable14_7
       4  ??DataTable15
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_10
       4  ??DataTable16_11
       4  ??DataTable16_2
       4  ??DataTable16_3
       4  ??DataTable16_4
       4  ??DataTable16_5
       4  ??DataTable16_6
       4  ??DataTable16_7
       4  ??DataTable16_8
       4  ??DataTable16_9
       4  ??DataTable17
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable19_2
       4  ??DataTable19_3
       4  ??DataTable19_4
       4  ??DataTable19_5
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable8
       4  ??DataTable8_1
      20  cJSON_AddItemReferenceToArray
      24  cJSON_AddItemReferenceToObject
      36  cJSON_AddItemToArray
      44  cJSON_AddItemToObject
      52  cJSON_AddItemToObjectCS
      16  cJSON_CreateArray
      26  cJSON_CreateBool
      80  cJSON_CreateDoubleArray
      16  cJSON_CreateFalse
      76  cJSON_CreateFloatArray
      76  cJSON_CreateIntArray
      16  cJSON_CreateNull
      38  cJSON_CreateNumber
      16  cJSON_CreateObject
      30  cJSON_CreateString
      72  cJSON_CreateStringArray
      16  cJSON_CreateTrue
      88  cJSON_Delete
      12  cJSON_DeleteItemFromArray
      12  cJSON_DeleteItemFromObject
      68  cJSON_DetachItemFromArray
      50  cJSON_DetachItemFromObject
     170  cJSON_Duplicate
      18  cJSON_GetArrayItem
      16  cJSON_GetArraySize
       8  cJSON_GetErrorPtr
      30  cJSON_GetObjectItem
      80  cJSON_InitHooks
      54  cJSON_InsertItemInArray
     188  cJSON_Minify
      32  cJSON_New_Item
      12  cJSON_Parse
     108  cJSON_ParseWithOpts
      14  cJSON_Print
      44  cJSON_PrintBuffered
      14  cJSON_PrintUnformatted
      68  cJSON_ReplaceItemInArray
      72  cJSON_ReplaceItemInObject
       4  cJSON_free
       4  cJSON_malloc
      80  cJSON_strcasecmp
      46  cJSON_strdup
      50  create_reference
     116  ensure
       4  ep
       8  firstByteMark
     158  parse_array
     218  parse_hex4
     348  parse_number
     258  parse_object
     422  parse_string
     170  parse_value
      26  pow2gt
     644  print_array
     360  print_number
    1228  print_object
      10  print_string
     514  print_string_ptr
     268  print_value
      22  skip
       6  suffix_object
      34  update

 
     4 bytes in section .bss
     8 bytes in section .data
    78 bytes in section .rodata
 6 922 bytes in section .text
 
 6 922 bytes of CODE  memory
    78 bytes of CONST memory
    12 bytes of DATA  memory

Errors: none
Warnings: 27
